# 알고리즘 5주차 스터디
- 목표 : 11일차 ~ 12일차 (그리디, 정수론)
- 발표 : 정수론 - 오일러의 피
### 그리디2
```
// 문제035 - 회의실 배정하기 (백준 1931 [실버1])
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

bool cmp(pair<int, int> &a, pair<int, int> &b){
    if(a.second == b.second) return a.first < b.first;
    else return a.second < b.second;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long N;
    cin>>N;
    vector <pair<int, int>> meetingTime;
    for (long i=0; i<N; i++){
        long start, end;
        cin>>start>>end;
        meetingTime.push_back(make_pair(start, end));
    }
    
    // 끝난 시간을 기준으로 정렬
    sort(meetingTime.begin(), meetingTime.end(), cmp);
    
    long count = 1;
    long currentTime = meetingTime[0].second;
    for (int i = 1; i < N; i++) {
        if (meetingTime[i].second >= currentTime && meetingTime[i].first >= currentTime){
            currentTime = meetingTime[i].second;
            count++;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/user-attachments/assets/9198d078-6d65-4b9f-9239-d10a6eaa8d76)

**문제 풀이** : N개의 회의를 겹치지않고 최대한 많은 회의를 수행하기 위한 알고리즘을 설계하는 문제이다. 회의가 짧을수록 이득일 것이다. 회의를 종료시간을 기준으로 정렬을 한다. 그리고 이제 종료시간이 가장 짧은 회의를 시작하고, 이전 회의에서 끝난 시간보다 시작시간이 크거나 같으면서 종료시간이 가장 짧은 회의를 선택한다. 
이를 반복하여 모든 회의를 둘러보면 된다.
시작하자마자 끝나는 회의가 존재할 수 있기에, 종료시간보다 다음 종료시간이 무조건 크리라는 법이 없다 (1시부터 2시까지 있는 회의 뒤에 2시부터 2시까지 하는 회의가 있을 수 있음) 그래서 크거나 같다로 해야한다. (크다로 해서 틀렸었음).

```
// 문제036 - 최솟값을 만드는 괄호 배치 찾기 (백준 1541 [실버2])
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    return 0;
}
```