# 알고리즘 5주차 스터디
- 목표 : 11일차 ~ 12일차 (그리디, 정수론)
- 발표 : 정수론 - 오일러의 피
### 그리디2
```
// 문제035 - 회의실 배정하기 (백준 1931 [실버1])
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

bool cmp(pair<int, int> &a, pair<int, int> &b){
    if(a.second == b.second) return a.first < b.first;
    else return a.second < b.second;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long N;
    cin>>N;
    vector <pair<int, int>> meetingTime;
    for (long i=0; i<N; i++){
        long start, end;
        cin>>start>>end;
        meetingTime.push_back(make_pair(start, end));
    }
    
    // 끝난 시간을 기준으로 정렬
    sort(meetingTime.begin(), meetingTime.end(), cmp);
    
    long count = 1;
    long currentTime = meetingTime[0].second;
    for (int i = 1; i < N; i++) {
        if (meetingTime[i].second >= currentTime && meetingTime[i].first >= currentTime){
            currentTime = meetingTime[i].second;
            count++;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/user-attachments/assets/9198d078-6d65-4b9f-9239-d10a6eaa8d76)

**문제 풀이** : N개의 회의를 겹치지않고 최대한 많은 회의를 수행하기 위한 알고리즘을 설계하는 문제이다. 회의가 짧을수록 이득일 것이다. 회의를 종료시간을 기준으로 정렬을 한다. 그리고 이제 종료시간이 가장 짧은 회의를 시작하고, 이전 회의에서 끝난 시간보다 시작시간이 크거나 같으면서 종료시간이 가장 짧은 회의를 선택한다. 
이를 반복하여 모든 회의를 둘러보면 된다.
시작하자마자 끝나는 회의가 존재할 수 있기에, 종료시간보다 다음 종료시간이 무조건 크리라는 법이 없다 (1시부터 2시까지 있는 회의 뒤에 2시부터 2시까지 하는 회의가 있을 수 있음) 그래서 크거나 같다로 해야한다. (크다로 해서 틀렸었음).

```
// 문제036 - 최솟값을 만드는 괄호 배치 찾기 (백준 1541 [실버2])
#include <iostream>
#include <vector>
#include <regex>
#include <string>
using namespace std;

vector<string> split(const string& str, const string& regex_str){
    vector<std::string> tokens;
    regex re(regex_str);
    sregex_token_iterator it(str.begin(), str.end(), re, -1);
    sregex_token_iterator reg_end;
    for ( ; it != reg_end; ++it) {
        if (!it->str().empty()) { // 공백 문자열 무시
            tokens.push_back(*it);
        }
    }
    return tokens;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    string problem;
    cin>>problem;
    vector <string> result = split(problem, "[-]");
    long sum = 0;
    for (long i=0; i<result.size(); i++){
        vector <string> temp = split(result[i], "[+]");
        for (long j=0; j<temp.size(); j++){
            if (i==0) {
                sum += stol(temp[j]);
            } else {
                sum -= stol(temp[j]);
            }
        }
    }
    cout<<sum;
    return 0;
}
```
![image](https://github.com/user-attachments/assets/8c41334a-d26f-4cff-97eb-bfd9a36840c7)
**문제 풀이** : -를 만나면 다음 -를 만나기 전까지 뒤에 있는 모든 수들을 더한다는 형식으로 문제를 접근했다. split 함수를 사용해서 우선 -를 기준으로 나누었다. 그러면 이제 +로 묶여있는 string 형태들만 배열에 남는다.
첫 숫자 묶음은 빼기 전 초기 형태를 담당한다. 따라서 -를 기준으로 나눈 배열 중에서 첫번째 배열의 묶음들은 +를 기준으로 split하여 모두 더해서 sum에 넣어준다.
이후 두번째 배열부터 +를 기준으로 split하여 모두 sum에서 빼준다. 두 번째 배열부터는 -로 묶인 숫자묶음이기에 -로 빼주는 것이다.
이렇게 끝까지 반복하면 최솟값의 형태가 나타나게 된다.

## 정수론
수의 성질을 탐구 및 공부하기 분야이다. 이번 주차에는 소수구하기, 오일러 피를 한다.
#### 소수 구하기
1보다 크면서 자기자신과 1 외에 약수가 없는 수를 소수라 한다. (자신보다 작은 2개의 자연수를 곱해 만들 수 없는 1보다 큰 자연수) 코딩테스트에서 종종 소수구하기 문제가 출제된다.

핵심 이론으로 **에라토테네스의 체**가 있다. 구하고자 하는 소수 범위만큼 1차원 배열을 생성. 각 배열에 1부터 N까지 숫자를 채워넣음. 2부터 시작하면서 현재 숫자가 존재할 때 (0이 아닐 때) 본인의 배수의 수를 갖는 모든 수들이 담겨있는 배열을 모두 0으로 초기화한다. (없앤다) 모든 배열값을 돌면서 이를 수행하면 최종적으로 남아있는 수들은 소수들만 남게 된다.

일반적인 에라토네테스 체는 O(N^2)의 시간복잡도지만 실제론 배수를 삭제하는 연산으로 인해 최적화되어 O(Nlog(logN)) 정도가 된다. 이러한 탓에 코딩테스트에서도 종종 쓰이는 해결방법이다.

```
// 문제037 - 소수 구하기 (백준 1929 [실버3])
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    return 0;
}
```