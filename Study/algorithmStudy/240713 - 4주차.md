# 알고리즘 4주차 스터디
- 목표 : 9일차 ~ 10일차 (이진 탐색, 그리디)
- 발표 : 그리디
### 9일차
##### 이진 탐색
정렬된 상태의 데이터에서 원하는 값을 찾아내는 알고리즘. 중앙값과 찾는 값을 비교하는 것을 반복하며 범위를 줄여나간다. O(logN)이라는 시간복잡도를 가지고 있다.
```
// 문제029 - 원하는 정수 찾기 (백준 1920 [실버4])
#include <iostream>
#include <algorithm>
using namespace std;

void search(long arr[], long findNum, int start, int end) {
    int mid = (start+end)/2;
    if (arr[mid] == findNum){
        cout<<"1"<<'\n';
        return;
    }
    if (start>=end){
        cout<<"0"<<'\n';
        return;
    }
    if (arr[mid] < findNum){
        search(arr, findNum, mid+1, end);
    } else if (arr[mid] > findNum){
        search(arr, findNum, start, mid-1);
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    int N;
    cin>>N;
    long arr[N];
    for (int i=0; i<N; i++){
        long number;
        cin>>number;
        arr[i] = number;
    }
    sort(arr, arr+N);
    int M;
    cin>>M;
    for (int i=0; i<M; i++){
        long findNum;
        cin>>findNum;
        search(arr, findNum, 0, N-1);
    }
    return 0;
}
```
![image](https://github.com/user-attachments/assets/ce6b2d9a-ca61-4648-b0d6-ea008587be9c)

**문제 풀이** : 나는 재귀함수를 활용하여 문제를 해결하였다. 그 외에는 start와 end를 활용하는 아이디어는 동일하게 문제를 해결하였다.

```
// 문제030 - 블루레이 만들기 (백준 2343 [실버1])
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    return 0;
}
```

```
// 문제031 - 배열에서 K번째 수 찾기 (백준 1300 [골드2])
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    return 0;
}
```

### 10일차
##### 그리디
현재 상황에서의 최선의 선택을 통해 그럭저럭 괜찮은 해를 얻어내는 알고리즘이다. 항상 최적해를 보장하지 않기 때문에 상황을 봐서 사용해야 함.
1) 해 선택 : 현재 상황에서의 가장 최선인 해를 선택
2) 적절성 검사 : 현재 선택한 해가 전체 제약 조건에 벗어나지 않나 검사
3) 해 검사 : 현재까지 선택한 해의 집합이 전체 문제를 해결할 수 있는지 검사. 못한다면 1로 돌아가서 반복

```
// 문제032 - 동전 개수의 최솟값 구하기 (백준 11047 [실버3])
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long N, price;
    cin>>N>>price;
    long arr[N];
    long moneyIndex = 0;
    long moneyCount = 0;
    for (int i=0; i<N; i++){
        cin>>arr[i];
        if (arr[i]<=price) {
            moneyIndex = i;
        }
    }
    while(price>0){
        long quot = price/arr[moneyIndex];
        moneyCount += quot;
        price -= arr[moneyIndex] * quot;
        moneyIndex--;
    }
    cout<<moneyCount;
    return 0;
}
```
![image](https://github.com/user-attachments/assets/aa2922b8-f4c5-4bbf-b699-ba64dce22d9b)

**문제 풀이** : 그리기는 항상 최선의 선택을 하는 알고리즘이다. 나는 이를 위해 가장 크게 나누어떨어질 수 있는곳의 index를 구하고, 해당 인덱스부터 올라가면서 동전의 몫 * 동전의 가격 만큼 K값에서 빼면서 K값이 0이 될때까지 진행하였다.
문제집에서는 동전수는 목표금액/현재동전가치로 나랑 똑같이 구했고, 목표금액을 갱신할 때 나는 목표가격 * 곱을 뺄셈하여 구했지만 문제집은 목표금액에서 현재 동전가치를 나머지연산하여 구했다. 

```
// 문제033 - 카드 정렬하기 (백준 1715 [골드4])
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    return 0;
}
```

```
// 문제034 - 동전 개수의 최솟값 구하기 (백준 11047 [실버3])
#include <iostream>
using namespace std;

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);

    return 0;
}
```
