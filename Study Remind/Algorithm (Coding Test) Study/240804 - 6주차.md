## 알고리즘 6주차 스터디
13일차 - 유클리드 호제법 (문제 3개)

유클리드 호제법이란 두 수의 최대공약수를 구하는 알고리즘이다.
일반적으로는 소인수분해를 통해 구한 공통된 소수들의 곱으로 표현이 가능하지만, 유클리드 호제법은 조금 더 간단하게 접근할 수 있다.

핵심 연산은 MOD(모듈러; 나머지 연산자)이다. MOD로 어떻게 최대공약수를 구할까?

1) 큰 수를 작은 수로 나누는 MOD 연산을 수행한다.
2) 앞 단계에서의 작은 수와 위에서 구한 MOD 연산 결괏값인 나머지로 또 MOD 연산을 수행한다.
3) 나머지가 0이 되는 순간의 작은 수를 최대공약수로 선택한다.

약수의 개념을 생각해보면, 특정 수 (예를 들면 10)를 어느 수로 나눌 때 나누어 떨어지냐? 이다. 10은 5로 나누어떨어지기에 5는 10의 약수라 볼 수 있다.
최대공약수는 10, 15가 있을 때 둘 모두 나누어 떨어질 수 있는 가장 큰 수를 의미한다. 여기서는 5가 되겠다.

이걸 MOD 연산으로 구한다는 것은, 둘을 우선 큰수에서 작은수로 나머지를 구하고, 작은수에서 나머지를 나머지연산해서 나누어 떨어진다면 둘 다 나누어떨어지는 약수를 찾을 수 있는 것이다.

15 % 10 = 5 이고, 10 % 5 = 0이기에 나누어 떨어진다. 따라서 15와 10의 최대공약수는 5인 것이다.
만약 18과 10을 예로 들자, 18 % 10 = 8 이고, 10 % 8 = 2 이다. 또한 8 % 2 = 0 이기에 최대공약수는 2가 되는 것이다.

점차 큰 수부터 내려오기에 최초로 0으로 나누어떨어지는것이 바로 **최대공약수**가 될 수 있다.

```
// 문제042 - 최소 공배수 구하기 (백준 1934 [실버5])
#include <iostream>
using namespace std;
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long N;
    cin>>N;
    for (int i = 0; i < N; i++) {
        long A, B;
        cin>>A>>B;
        long large;
        long small;
        if (A>B){
            large = A;
            small = B;
        } else {
            large = B;
            small = A;
        }
        long gcd = small;
        while (gcd>0){
            gcd = large % small;
            if (gcd == 0){
                break;
            }
            large = small;
            small = gcd;
        }
        cout<<A*B/small<<'\n';
    }
    return 0;
}
```
![image](https://github.com/user-attachments/assets/ca753d15-e30d-499f-9a16-0304aeaede9a)

**문제 풀이** : 최소공배수를 **A * B / 최대공약수** 로 구할 수 있다는 사실만 안다면 쉽게 풀 수 있다.
우선 유클리다 호제법을 적용하여 A와 B의 최대공약수를 구한다.
