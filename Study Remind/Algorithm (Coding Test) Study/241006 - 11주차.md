## 동적 프로그래밍
```
// 문제086 - 이친수 구하기 (백준 2193 [실버3])
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    long long dp[91][2]; // dp 배열 선언 (최대 90자리)
    dp[1][0] = 0; // 1자리 이친수는 0으로 시작할 수 없음
    dp[1][1] = 1; // 1자리 이친수는 1로 시작해야 함
    for (int i = 2; i <= n; i++) {
        dp[i][0] = dp[i-1][0] + dp[i-1][1]; // 마지막 자리가 0인 경우
        dp[i][1] = dp[i-1][0]; // 마지막 자리가 1인 경우
    }
    // N자리 이친수의 개수는 dp[n][0] + dp[n][1]의 합
    cout << dp[n][0] + dp[n][1] << endl;
    return 0;
}
```
![[Pasted image 20241006111553.png]]
문제 해설 : 최대 N의 크기가 90이라고 했다. 이차원 배열로 이친수를 구하였다. 이렇게 되면 최대 1번째 자리부터 90번째 자리까지 0 또는 1인 수를 저장할 수 있다.
초기로는 문제에서 주어진대로 식을 초기화한다. 첫번째 자리의 수는 무조건 1로 시작해야 한다. 이걸 기반으로 뒤의 값들을 채워나갈 수 있다. 누적합 개념이라고 보면 된다.
두번째 자리부터 N번째 자리까지 이전 자리가 1이었는지 0이었는지 본다.
현재 노드가 0이 들어가기 위해서는 이전 노드가 0 이나 1이든 상관없다.
하지만 현재 노드가 1이 들어가기 위해서는 이전 노드가 0일때만 가능하다.
이러한 내용을 토대로 점화식을 작성하면, 이전 자리수가 0일때와 1일때의 이친수 개수를 더하면 현재 자리수가 1일때 까지의 이친수 개수가 된다/ 이전 자리수가 0일때의 이친수 개수만 세면 현재 자리수가 0일때 까지의 이친수 개수가 된다.
최종적으로 N자리일 때 이 두 경우의 이친수 개수를 모두 더하면 N자리수일때의 총 이친수 개수가 된다.

```
// 문제087 - 2*N 타일 채우기 (백준 11726 [실버3])
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int dp[1001];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = (dp[i-1] + dp[i-2]) % 10007;
    }
    cout << dp[n] << endl;
    return 0;
}
```
![[Pasted image 20241006111656.png]]
문제 해설 : 이 문제는 2N타일을 채우기 위한 경우의 수를 모두 더하여 몇개인지 알려주는 문제이다. 동적프로그래밍 방식으로 이를 해결할 수 있는데, 우선 2x1일때, 2x2일때만 경우의 수를 계산하면 그 이후에는 국소적해결을 통해 그 이상의 경우도 해결할 수 있다.
우선 타일의 크기는 2x1이다. 이런 상황에서 첫 직사각형이 2x1이라면 세로로 세운 **1가지 경우의 수** 밖에 없다. 만약 첫 직사각형이 2x2라면 타일을 세로로 두개 세우거나, 가로로 두개 세우거나 **2가지 경우의 수**가 나타난다. 2x3 직사각형부터는 이러한 2x1때와, 2x2일때의 경우의수를 조합한 수가 될 것이다.
2x3은 2x1 이후에 2x2가 오거나, 2x2 이후에 2x1이 오거나인데, 이 둘의 경우의수를 더하면 2x3에서의 경우의수를 구할 수 있다.  그래서 점화식이 `dp[i]=dp[i-1]+dp[i-2]` 이다. 문제에서 출력에 10007로 나눈값을 출력하라 했으니, 그것까지해준다.
