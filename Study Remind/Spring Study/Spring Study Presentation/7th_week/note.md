# 7주차 - 섹션 2 중간 ~ 섹션 3

### 회원 도메인 실행과 테스트  
기본 자바로 구현하는 모습.  순수한 자바이고 스프링없이 해보았다.  
그런데 이 방식은 한계가 있음. 좋은 방식이 아니기에 Junit이라는 프레임워크를 사용할 것임  
요즘 코딩을 하려면 테스트 코드는 선택이 아닌 필수이다.  
join이라는 메소드를 테스트 코드를 통해서 검증해보았음.  
회원 도메인 코드가 설계 상 문제가 있을 것임. 무엇인가???  
다른 저장소로 변경할 때 OCP를 잘 준수할지, DIP는 잘 준수하는지.  
결국에는 한계가 있다. 구체화에 의존하는 문제가 있다...  

### 주문과 할인 도메인 설계  
회원은 상품을 주문할 수 있는데, 회원 등급에 따라 할인 정책이 달라지는 것.  
VIP의 경우 모든 상품에 1000원을 고정 할인해 줌. 근데 나중에 변경 가능.  
할인 정책은 변경 가능성이 높고 회사는 확신이 없다. 오픈 전까지 미루는 상황..  
이러한 미확정 상황에서 어떻게 해야할까?  
클라이언트의 주문 생성을 요청 => 주문 서비스는 회원의 ID를 조회하여 회원의 등급을 확인한다 => 그리고 회원 등급에 따라 할인을 적용 => 주문 서비스에서 할인 결과를 포함하여 주문 결과를 반환  
위 상황을 고려하여 할인 정책의 경우 여러 가능성을 구현체 여러개로 만들어 두고 구현체만 바꿔 끼우면 된다.  
( 보통 구현체가 단 하나만 있으면 interface명 뒤에 Impl이라고 적는 편이다.  
ex - OrderService 인터페이스의 구현체 OrderServiceImpl )  
이렇게 가능성을 만들어두고 갈아끼우면 주문서비스 쪽은 변경하지 않고 완성할 수 있다.  

### 주문과 할인 도메인 개발  
할인 패키지를 만들고 그 안에 할인정책 인터페이스를 만든 뒤, 고정금액할인 방식으로 구현한다. 차후 비율할인도 만들어 놓을 수 있음.  
주문패키지를 만들어 그 안에서 할인 비율에 따른 계산을 하여 결과값을 도출할 수 있도록 만든다.  
나중에 보기 편리하도록 toString()기능을 사용했다. 이러면 print로 order 객체만 출력하면 자동으로 toString 메소드가 실행된다.  
OrderService를 구현해야하는데 이곳에서 주문을 요청받을 때 클라이언트의 회원정보와 상품, 그리고 가격을 넘기게 된다.  
OrderServiceImpl에서 먼저 회원데이터베이스, 할인정책을 구현하고 (현재는 우선 메모리DB, 고정할인정책) OrderService의 주문생성 메소드를 오버라이딩한다.  
데이터베이스와 할인정책을 통해서 얻은 회원의ID, 아이템의 이름과 가격을 받은 뒤 이것들을 사용하여 Order객체에 이 값들을 포함시켜준다.  

### 주문과 할인 도메인 실행과 테스트  
메인, 테스트 둘다 테스트 해본 결과 문제 없이 잘 구현되었다.  
![image1](https://user-images.githubusercontent.com/108540812/217837600-9dbbcc53-f6b8-4549-a381-35e449c22a7f.png)  

## 섹션3  

### 새로운 할인 정책
새로운 정책을 적용하려하니 문제... DIP, OCP를 못지킴  
이걸 해결하고자 여러 과정을 거치는데 이를 거치다보면 스프링컨테이너가 왜 탄생했나 알 수 있게 된다.  
새로운 할인정책은 고정할인이 아닌, 정률할인으로 적용시키는 것!  
1000원을 할인해주는 기존 정책과 달리 이번에는 10%를 할인해주는 정책이다.  
> 애자일 소프트웨어 선언 - 공정과 도구보다 개인과 상호작용을,  
포괄적 문서보단 작동하는 소프트웨어를,  
계약 협상보다 고객과의 협력을,  
계획을 따르기보다 변화에 대응하기를

을 의미한다.  
Ctrl+Shift+T로 테스트를 생성할 수 있다.  
VIP일 경우, BASIC일 경우 두가지의 경우에서 할인이 잘 적용되고 적용되지 않는지 확인하였다.  

### 새로운 할인 정책의 문제점  
적용을 위해선 OrderServiceImpl로 가서 discountPolicy 대상을 변경해야함(고정-> 정률)  
즉, 할인정책을 변경하려면 클라이언트인 OrderServiceImpl를 고쳐야하는 것이다.  
이게 무엇이 문제? -> 역할구현 충실히 분리하였고 다형성 활용하고 인터페이스와 구현객체 구현했다. 하지만...  
OCP와 DIP를 충실히 구현하지 못 했다.  
추상클래스인 DiscountPolicy만 아니라 구현클래스 Rate(Fix)DiscountPolicy에도 의존하고 있다.  
즉, 변경 및 확장을 위하여 클라이언트를 건드리는 상황이 나온 것! 이것은 DIP의 위반이다.  
항상 추상화에만 의존하라는 DIP에 위반을 한 것인데.. 이 때문에 할인정책을 변경하기 위해 클라이언트(OrderServiceImpl)의 코드도 변경해야 하는 OCP위반까지 함께 동반되는 것이다.  
근데 이 두개를 위반하지 않고 구현하는 것이 가능할까?  
DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경해야 함  
구현체에 의존하는 것을 다 지우는 것이다.  
구현체가 없는데 어떻게 실행이 되는가... 실제로 실행하면 에러가 난다.  
해결 -> 누군가 구현객체를 대신 생성하고 주입해주어야 한다. 그러면 해결이 된다.  

### 관심사의 분리  
공연을 떠올려보면 각각의 인터페이스가 배우의 역할이다. 그러면 실제 배역에 맞는 배우는 누가 선택??  
배우의 역할이 배역을 고르는게 아니라, 실제론 공연기획자가 배역에 맞는 배우들을 섭외할 것이다.  
이처럼 관심사를 분리하여 구현객체를 생성하고 이를 연결하여 의존관계를 주입해주는 일을 수행하는 설정클래스를 만들어야 한다.  
애플리케이션도 이런 방식으로 개발되어야 한다. 본인의 역할만 수행하도록 해야함.  
> AppConfig의 등장

MemberServiceImpl의 구현체 대신 생성자를 사용하여 입력된 설정에 맞는 구현체를 구현한다. 생성자를 통한 생성자 주입  
OrderServiceImpl도 생성자로 다 받아낸다.  
이 형태를 통해 멤버서비스구현체, 오더서비스구현체들은 본인들에게 어떠한 구현체가 들어올지 모르는 코드가 완성된다. AppConfig에서 생성자를 통해 생성하여 넘겨주기 때문에 그때야 알게 된다.  
어떤 구현객체가 들어올 지는 AppConfig를 통해서만 결정된다.  
이제 Impl들은 의존관계 고민 없이 실행에만 집중하면 되는 것이다.  
관심사가 잘 분리되었다!  
이 모습이 클라이언트 입장에서는 외부에서 의존관계를 넣어주는 것과 같다고하여 이것을 DI(Dependency Injection), 의존관계 주입 이라고 부른다.  
MemberApp과 OrderApp에 둘 다 AppConfig를 만들어서 이를 사용하여 구체화하도록 설정하면, 이제 이 둘도 구현체에 의존하지 않는 상태로 만들 수 있다.  
Test의 경우에는 여러 구문이 실행될 수 있으니 @BeforeEach구문을 사용하여 테스트 메소드가 실행될 때마다 AppConfig가 생성되고 각 memberService나 orderService에 appconfig의 메소드들로 인하여 생성자주입이 실행되도록 설정해두었다.  
이제 DIP는 잘 지켜지게 되었다.  
이처럼 AppConfig로 관심사를 확 분리하였다. 이제부터는 AppConfig가 구현체를 설정할 것이다.  
각 클래스들은 본인들의 기능을 실행하는 데에만 집중하면 된다.  

### AppConfig 리팩터링  
현재의 AppConfig를 더욱 역할, 구현이 한 눈에 잘 보이도록 만든다.  
어떻게? getter같은 기능을 사용하여 리턴으로 구체화를 하도록 하여 빠르게 파악하기 쉽게 한다. 또한 중복도 제거되는 모습을 보인다.  

### 새로운 구조를 사용한 할인 정책 사용  
이제 추가된 AppConfig를 사용하여 새로운 할인정책으로 변경해볼 것이다.  
AppConfig 내에 있는 discountPolicy의 리턴값을 FixDiscountPolicy에서 RateDiscountPolicy로만 바꾼다.  
이제 변경이 끝난 것이다. 이제 할인정책이 갑자기 변경되도 AppConfig만 수정하면 된다.  
OrderServiceImpl을 포함한 사용영역을 변경할 필요가 없어졌다.  
오직 AppConfig(구성영역)만 수정하면 이러한 변경사항을 감당할 수 있게 되었다.  
그렇기 위해서는 AppConfig에 모든 사용 영역의 내용들을 잘 담아야 한다.  
마치 공연기획자가 공연에 관한 모든 것들을 잘 알고있어야 하는 것처럼...  
DIP를 만족하고 있고 OCP도 가능하게 되었다.  

### 좋은 객체 지향 설계의 5원칙을 얼마나 적용했을까  
SRP, DIP, OCP를 만족했다고 말할 수 있다.  
SRP(단일책임원칙) - 단일 책임 원칙을 따르기 위해 관심사를 분리함. 구현 객체의 생성과 연결을 AppConfig가 담당하고 다른 객체들은 실행에만 집중할 수 있음  
DIP(의존관계역전원칙) - 구체화에 의존하고 있던 기존의 형태를 AppConfig를 통해 외부에서 의존성을 주입시켜주는 것을 볼 수 있음  
OCP(확장엔 개방적 변경엔 폐쇄적) - 애플리케이션을 사용영역과 구성영역으로 나누었고 그 덕에 소프트웨어 요소를 새롭게 확장해도 사용영역의 변경은 닫혀있을 수 있게 되었다. 구성영역만 변경하면 됨  

### IoC, DI, 컨테이너  
IoC는 제어의 역전(Inversion of Control)을 뜻한다.  
프로그램의 제어를 AppConfig가 모두 가져간다. 구현체들은 제어권이 다 넘어가서 없다.  
이처럼 프로그램에 대한 모든 제어 흐름을 직접이 아닌, 다른 외부에서 관리하는 것을 IoC라고 한다.  
프레임워크와 라이브러리는 헷갈리기 쉽다.  
프레임워크는 내가 작성한 코드를 대신 제어하고, 대신 실행하는 것을 의미한다.(Junit)  
하지만 내가 작성한 코드가 직접 제어흐름을 담당하면 그것은 프레임워크가 아닌 라이브러리이다.  
지금 만든 코드로 보면, OrderServiceImpl은 인터페이스들에 의존하고 있다.  
의존관계는 '정적인 클래스 의존관계, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계' 이 둘을 분리하여 생각해야함  
의존을 추상화에만 하고 있기 때문에 어떤 객체가 들어올 지 인터페이스 코드만 보고는 분석할 수 없다.  
애플리케이션 실행 시점에 어떠한 의존관계가 연결될지 결정된다. 실행 전에는 AppConfig가 생성하기 이전이기에 어떤 것이 들어올지 모른다.  
이처럼 DI(의존관계 주입)를 사용하면 정적 의존관계를 전혀 변경하지 않고(애플리케이션 코드를 수정 안함) 동적 의존관계를 쉽게 변경 가능하다.  
그럼 과연 IoC컨테이너, DI컨테이너는 무엇인가?  
그 기능을 해주는 컨테이너라고 보면 된다. AppConfig처럼 객체를 생성하고 관리하며 의존관계를 연결해주는 것.  
의존관계 주입에 초점을 맞추기에 최근엔 DI컨테이너(Dependency Injection)이라 주로 부름  
어셈블러, 오브젝트 팩토리 등으로 불리기도 함  

### 스프링 전환  
이제 스프링으로 도입할 때이다.  
스프링이 얼마나 대단한지 깨달을 수 있는 시간이다.  
AppConfig에 @Configuration과 그 메소드들에 @Bean을 붙여서 컨테이너에 등록한다.  
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(AppConfig.class); 를 써서 Appconfig 클래스에 있는 Bean들을 스프링에 등록한다.  
OrderApp도 마찬가지..  
기존에는 개발자가 직접 AppConfig로 DI를 해주었지만 이제 스프링 컨테이너로 이를 사용  
스프링 컨테이너는 @Configuration이 붙은 것을 구성정보로 활용. 이 안에 @Bean이 붙은 메소드 모두 호출함  
호출한 메소드들은 모두 스프링컨테이너에 등록한다. 그리고 그 메소드명을 Bean의 이름으로 삼는다.  
또한 이제부터 스프링 컨테이너로 필요한 Bean을 찾음. 이것에 사용하는 것이 getBean이다.  
코드가 오히려 복잡해진 것 같은데 어떤 장점이 생긴 것일지...?  
앞으로 개발을 하면서 스프링 컨테이너에 등록하는 것으로 얻을 수 있는 이점이 정말 많다!  