## 지오메트리
- Geometry 는 Position, Normal, Color, UV, Vertex Index를 가지고있고 렌더링 시에 이를 GPU에 전달한다. 사용자 정의 데이터도 저장해서 전달할 수 있다.
- three.js에 정의된 기본 Geometry가 있다. Box, Circle, Cone 등... 좀 많음. 전부 R3F에서 사용 가능하다.
- R3F에서는 mesh는 '반드시' Geometry와 Material을 가져야 한다.
- mesh내에 mesh를 넣어 이중으로 사용가능하다. (240411참고)
- mesh에 대한 Geometry 지정 방식은 세가지. 우리가 했던 방식(mesh 내에 Geometry를 자식으로 넣음)이 그 중 하나이다.
- 다른 방법은 **Drei**라는 라이브러리를 사용하는 것이다. deri는 R3F에서 사용할 수 있는 유용한 컴포넌트 모아놓은 라이브러리. 많이 사용됨.

### Drei 라이브러리
- 두번째 방법으로는 drei 라이브러리를 사용하는것. Box라는 태그로 바로 BoxGeometry를 생성할 수 있다. (와우) 이후 내부에 Material만 넣으면 된다.

### Three.js ( 꽤 마음에 드는 방법 )
- 세번째 방법으로는 3js에서 사용하는 코드를 활용하는 것이다.
- 새로운 컴포넌트를 만들고 (react에서 만들듯이) new THREE.BoxGeometry();를 통해 새로운 인스턴스를 만들고 해당 컴포넌트 return값에 < mesh {...props} geometry={geom} >< /mesh > 과 같이 넣어주면 해당 커스텀 컴포넌트를 참조하는 코드에서 < MyBox position={[0, 0, 0]}/> 과 같이 props값을 넣어서 생성할 수 있게된다.

### 내생각
- 아니면 Drei방법에 세번째 방법을섞어서 커스텀 컴포넌트를 편리하게 만들수있을지도!?

### mesh 테두리 선
- mesh를 생성하고 color가 아닌, emissive={색상} wireframe={true} 를 통해 색상있는 wireframe을 설정할 수도 있다.
- 둘다 boxGeometry를 받아오는데, 이는 두번 boxGeometry를 가져오는 비효율?적인 느낌이다. 같은 geometry라면 useRef와 useEffect와 같은 메소드를 통해 초기 시작 시에 물체에 있는 geometry속성값을 wireFrame의 geometry값으로 대입시켜주면 같은 geometry를 공유해서 사용가능하다.

### boxGeometry args
- Geometry는 args라는것으로 다양한 인자값을 넣을수있는데, 총 6개의 값을 배열로 넣을수있다. 해당 값들은 default값이 각각 1이다.
- [x scale, y scale, z scale, x divide, y divide, z divide] 같다는 나만의 예측..? 맞다. 처음 3개가 size, 뒤에 3개가 segments이다. (몇개로 나눌지)

### Controller를 통한 조작
- npm install leva (UI로 변경가능하게 해준다.)
- useControls를 통해 가져오고, xSize라는것을 정의한뒤 xSize: {value:1, min:0.1, max:5, step:0.01} 이라고 설정하면 기본값 1, 최소0.1, 최대5, 단계는 0.01씩인 xSize라는 이름의 UI컨트롤러가 생긴다.! 그리고 xSize라는것을 원하는 x값 위치에다가 넣어주면 연동끝
- 이렇게 여러개의 컨트롤러를 원하는대로 만들 수 있다.
- 근데 ui로 아무리 변경해도 ref를 통해 참조하는 wireframe의 값은 변경되지 않는다. 이 경우에 useEffect()의 감시변수로 xSize, ySize, ..., zSegments를 전부 넣어서 변경사항을 적용할 수 있게 했다.
- 이상 Geometry 파악을 위한 기초 끝