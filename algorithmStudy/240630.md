# 알고리즘 1,2주차 스터디
- 목표 : 1일차 ~ 6일차
- 발표 : 2일차, 5일차
### 5일차 이어서
- 정렬 : 선택 정렬 - 선택 정렬은 코딩테스트에서는 잘 활용되지 않는다. 전체 배열에서 가장 최솟값(최댓값)을 찾은 뒤, 가장 끝 원소와 교환하고 배열의 수를 -1 시킨다. (혹은 탐색 시작 범위를 +1 시킨다) 이를 반복하여 완성시키는 알고리즘이다. 탐색 시작 범위가 데이터 끝까지 도달하면 종료한다.
- #### 내림차순으로 자릿수 정렬하기
```
// 문제017 - 내림차순으로 자릿수 정렬하기 (백준 1427 [실버5])
#include <iostream>
#include <string>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    string numbers;
    cin>>numbers;
    long arr[numbers.length()];
    for(long i=0; i<numbers.length(); i++){
        arr[i] = numbers[i] - '0';
    }
    for (long i=0; i<numbers.length(); i++){
        long maxIndex = i;
        for (long j=i; j<numbers.length(); j++){
            if(arr[maxIndex] < arr[j]) {
                maxIndex = j;
            }
        }
        long temp = arr[i];
        arr[i] = arr[maxIndex];
        arr[maxIndex] = temp;
    }
    for (long i=0; i<numbers.length(); i++){
        cout<<arr[i];
    }
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/fc0d28b6-b251-4546-8e1c-051e079a0488)

선택정렬 알고리즘을 활용해서 문제를 해결했다. 자바에서는 substring을 사용하는 모양인데, 나는 C++이기에 값들을 한줄에 string으로 받아서 각 위치에 있는 char들을 - '0' 으로 정수로 변환하여 정수배열에 저장하였다. 이렇게 배열에 모든 값을 입력받은뒤, index값을 i번째부터 시작해서 배열 끝까지 탐색 한다. (처음엔 0번 index부터 n-1번까지 탐색) 탐색을 진행하며 최대값을 가진 index를 저장한다. 탐색을 마치고 나서 최대값을 가진 index와 가장 앞의 index의 수를 교환한다. 이후 i는 +1씩 늘어나며 점점 작은 범위를 탐색하게 된다. 
### 6일차
- 정렬 : 삽입 정렬 - 삽입 정렬은 이미 정렬되어 있는 범위에 데이터를 삽입하는 방식으로 구현하는 정렬 알고리즘이다. 이러한 원리때문에 어느정도 정렬이 되어있는 경우 더 좋은 효율을 보인다. 평균적인 시간 복잡도는 O(n^2)으로 느린 편이다. 삽입 위치를 탐색하는 과정에서 이진 탐색과 같은 탐색 알고리즘을 활용하여 시간복잡도를 개선할 수 있다.
- #### ATM 인출 시간 계산하기
```
// 문제018 - ATM 인출 시간 계산하기 (백준 11399 [실버3])
#include <iostream>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    long arr[N];
    long calSum;
    for (long i=0; i<N; i++){
        cin>>arr[i];
    }
    for (long i=1; i<N; i++){
        long index = i;
        for (long j=i-1; j>=0; j--){
            if (arr[index]<arr[j]) {
                long temp = arr[j];
                arr[j] = arr[index];
                arr[index] = temp;
                index--;
            } else {
                break;
            }
        }
    }
    calSum=arr[0];
    for (long i=1; i<N; i++){
        arr[i]=arr[i-1]+arr[i];
        calSum+=arr[i];
    }
    cout<<calSum;
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/1b20ef13-6060-4275-9989-52c28d807552)

삽입정렬에 누적합 개념을 활용하여 해결하였다. 삽입정렬을 통해 우선 데이터를 정렬한다. 이후 정열된 데이터를 활용해 누적합을 계산한다. 누적합을 모두 더한 것이 모든 사람들이 걸린 시간이다.
- 정렬 : 퀵 정렬
