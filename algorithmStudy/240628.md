# 알고리즘 1,2주차 스터디
- 목표 : 1일차 ~ 6일차
- 발표 : 2일차, 5일차
### 1일차
 - 코딩테스트 준비하기
 - #### 시간 복잡도
	일반적으로 **1억번의 연산을 1초**로 본다. 예시로, 시간 제한이 2초라면 2억 번 이하의 연산으로 문제를 해결해야 한다.
	빅오메가, 빅오, 빅세타가 있으며 빅오메가는 BestCase를 나타낸 것 (최소 어느정도 연산이 걸리는지), 빅오는 WorstCase를 나타낸 것 (최대 어느정도 연산이 걸리는지), 빅 세타는 빅오메가와 빅오가 모두 만족하면 된다. AverageCase라고도 불림
	코딩테스트에서는 빅 오(O(n)) 표기법으로 수행시간을 계산하는 것이 좋다. 다양한 케이스를 통과해야하기에 최악의 경우까지 생각해야 하는 것이다.
	
	**연산 횟수는 알고리즘 시간 복잡도 * 데이터의 크기**로 구할 수 있다.
	이 공식을 토대로 만약 정렬 알고리즘에서 N의 값이 100만개 이고, 2초 내에 해결해야 한다면, 버블정렬은 O(n^2)이기에 100만^2 > 2억이라는 결과에 따라 부적합한 정렬이라고 판단할 수 있다. 반면 병합정렬은 O(nlogn)이고, 2억보다 작은 연산횟수가 나오기에 적합한 알고리즘이라고 판단할 수 있다. 이처럼 데이터 크기(N)와 시간복잡도를 활용하여 알고리즘의 사용 적합성을 판단할 수 있게 된다.
	시간 복잡도를 바탕으로 코드 로직을 개선할 수도 있다. 그를 위해 우선 시간복잡도를 도출해야한다.
	1) 상수는 시간 복잡도 계산에서 제외.
	2) 가장 많이 중첩된 반복문 수행 횟수가 시간 복잡도의 기준이 된다. 
	연산횟수가 N인 경우와 3N인 경우 3배의 차이나 나지만, 코딩테스트에서는 이러한 상수는 무시하기에 두 코드 모두 시간복잡도는 O(n)으로 동일하다. 코딩테스트는 **가장 많이 중첩된 반목분을 기준으로 도출**하기에, 이중 for문 1개와 일반 for문 10개가 있더라해도 시간복잡도는 O(n^2)으로 이중 for문이 기준이 된다.
- #### 디버깅
	**프로그램에서 발생하는 문법 오류나, 논리 오류를 찾아 바로잡는 과정**을 디버깅이라 한다.
	디버깅은 코딩테스트에 반드시 필요한 기술이기에 꼭 익히고 응시해야한다.
	디버깅을 하는 방법은, 디버깅 하고자하는 줄에 중단점을 설정하고, IDE의 디버깅 기능을 실행하며 한줄씩 실행하거나, 다음 중단점까지 실행하며 변수값을 추적하여 의도에 맞게 코드가 실행되는지 파악한다. 원하는 수식을 입력하여 논리 오류를 파악할수도 있다. 
	잦은 실수가 발생하는 부분들이 있다.
	1) 변수 초기화 오류
	2) 반복문에서 인덱스 범위 지정 오류
	3) 잘못된 변수 사용 오류
	4) 자료형 범위 오류 (코딩 테스트는 int보다 long을 쓸일이 많다)
### 2일차
- 자료구조 : 배열과 리스트
- #### 배열과 리스트
	배열과 리스트의 차이
	배열 : 메모리의 연속공간에 값이 채워져있는 형태의 자료구조
	1) 인덱스 사용하여 값에 바로 접근 가능
	2) 새로운 값 삽입, 삭제가 어려움. 왜냐면 **해당 인덱스 주변값들을 이동시키는 과정 필요**
	3) 배열 크기는 선언 시 지정 가능. 한번 선언하면 크기를 늘리거나 줄일 수 없음
	4) 구조가 간단하여 코딩테스트에 많이 사용
	리스트 : 값과 포인터를 묶는 '노드'라는 것을 포인터로 연결한 자료구조
	1) 인덱스가 없기에 값 접근을 위해 Head 포인터부터 순서대로 접근해야함. **값에 접근하는 속도가 느리다**
	2) 포인터로 연결되어 있기에 **삽입, 삭제 연산이 빠르다**
	3) 선언 시 크기를 별도로 지정하지 않아도 된다. **리스트는 가변크기이다.** 크기가 변하기 쉬운 데이터를 다루기에 적절하다
	4) 포인터 저장공간이 필요하여 배열보다 구조가 복잡하다
```
// 문제001 - 숫자의 합 구하기 (백준 11720 [브론즈2])
using System;
namespace Algorithm {
    class Program {
        public static void Main(string[] args) {
            int N = int.Parse(Console.ReadLine());
            string numbers = Console.ReadLine();
            int sum = 0;
            for (int i=0; i<N; i++)
            {
                sum += int.Parse(numbers[i].ToString());
            }
            Console.WriteLine(sum);
        }
    }
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/b5057b9a-19a6-4a27-b945-973d6f61bcca)
```
// 문제002 - 평균 구하기 (백준 1546 [브론즈1])
using System;
namespace Algorithm {
    class Program {
        public static void Main(string[] args) {
            int N = int.Parse(Console.ReadLine());
            string scores = Console.ReadLine();
            string[] scoreArray = scores.Split(' ');
            float max = float.Parse(scoreArray[0].ToString());
            for (int i=1; i<N; i++)
            {
	            float number = float.Parse(scoreArray[i].ToString());
	            if (number > max) 
		            max = number;
            } 
            double sum = 0;
            for (int i=0; i<N; i++)
            {
	            float number = float.Parse(scoreArray[i].ToString());
	            sum += number/max*100;
            }
            Console.WriteLine(sum/N);
        }
    }
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/92f9bd91-3f4d-45ff-97fb-f2b6d82d20d8)
ReadLine과 Split을 메소드를 활용하여 값을 입력받고 숫자들을 분리, 이후 int.Parse나 float.Parse 메소드로 형변환을 시켜준뒤, 해당 값들을 활용해서 값을 구한다.

- 자료구조 : 구간 합
### 3일차
- 자료구조 : 투 포인터
- 자료구조 : 슬라이딩 윈도우
### 4일차
- 자료구조 : 스택과 큐
### 5일차
- 정렬 : 버블 정렬
- 정렬 : 선택 정렬
### 6일차
- 정렬 : 삽입 정렬
- 정렬 : 퀵 정렬
