# 알고리즘 1,2주차 스터디
- 목표 : 1일차 ~ 6일차
- 발표 : 2일차, 5일차
### 3일차
- 자료구조 : 투 포인터 - 두 개의 포인터로 알고리즘 시간 복잡도를 최적화 함. 
- #### 연속된 자연수의 합 구하기
```
// 문제006 - 연속된 자연수의 합 구하기 (백준 2018 [실버5])
#include <iostream>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    long start, end;
    start =1, end = 1;
    long sum = 1;
    long count = 0;
    while(end<=N){
	    // 디버깅용 start와 end값 표시
        // cout<<start<<' ';
        // cout<<end<<'\n';
        if (sum<N){
            sum = sum + ++end;
        } else if (sum>N){
            sum = sum - start++;
        } else {
            count++;
            sum = sum + ++end;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/e5774a18-244f-4f44-9942-cfd93e0b2213)

```
// 문제007 - 주몽의 명령 (백준 1940 [실버4])
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N, M;
    long sum;
    long count = 0;
    cin>>N>>M;
    long arr[N];
    for (int i=0; i<N; i++){
        cin>>arr[i];
    }
    sort(arr, arr+N);
    long A=0, B=N-1;
    while(A<B) {
        sum = arr[A]+arr[B];
        if (sum>M){
            B--;
        } else if (sum<M){
            A++;
        } else {
            count++;
            A++;
            B--;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/b9be5b60-d003-4939-9d09-f35b16debd91)
갑옷을 조합해서 수를 만드는 것.
1) 우선 배열을 정렬해주어 오름차순으로 둔다. 두개의 갑옷의 고유값을 더하여 M인지를 판단하는 것이기에 번호가 가장 낮은 것, 높은 것. 두 부분에 포인터를 둔다.
2) 이후 두 위치의 값을 더했을 때 M보다 크면 높은값 포인터를 낮추고, M보다 작아지면 낮은값 포인터를 높인다. 이렇게 차츰 범위를 줄여가며 계산한다.
3) 만약 두 포인터의 합이 M값이라면 낮은값 포인터를 높이고 높은값 포인터는 낮추면 된다. 둘 중 하나만 움직여도 되지만, 어차피 이후에 다른 포인터의 움직임이 필요로해진다. 예를 들면 3와 7이 합이라 M값인 10이 된다고 했을 때, 7을 6으로 낮추면 어차피 M값 보다 작은 9가 되기에 낮은 포인터도 올려야하는 상황이 생긴다. 이처럼 어차피 일어날 것이기에 낮은 포인터와 높은 포인터를 동시에 움직이는 것이다.
4) 이렇게 범위를 좁혀가다가 낮은값 포인터가 높은값 포인터보다 위치가 높거나, 혹은 같은 위치에 있다면 종료한다. (더 나가면 중복값이 됨)

```
// 문제008 - '좋은 수' 구하기 (백준 1253 [골드4])
#include <iostream>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    for ()
    return 0;
}
```
- 자료구조 : 슬라이딩 윈도우
### 4일차
- 자료구조 : 스택과 큐
### 5일차
- 정렬 : 버블 정렬
- 정렬 : 선택 정렬
### 6일차
- 정렬 : 삽입 정렬
- 정렬 : 퀵 정렬
