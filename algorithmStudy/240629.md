# 알고리즘 1,2주차 스터디
- 목표 : 1일차 ~ 6일차
- 발표 : 2일차, 5일차
### 3일차
- 자료구조 : 투 포인터 - 두 개의 포인터로 알고리즘 시간 복잡도를 최적화 함. 
- #### 연속된 자연수의 합 구하기
```
// 문제006 - 연속된 자연수의 합 구하기 (백준 2018 [실버5])
#include <iostream>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    long start, end;
    start =1, end = 1;
    long sum = 1;
    long count = 0;
    while(end<=N){
	    // 디버깅용 start와 end값 표시
        // cout<<start<<' ';
        // cout<<end<<'\n';
        if (sum<N){
            sum = sum + ++end;
        } else if (sum>N){
            sum = sum - start++;
        } else {
            count++;
            sum = sum + ++end;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/e5774a18-244f-4f44-9942-cfd93e0b2213)

- #### 주몽의 명령
```
// 문제007 - 주몽의 명령 (백준 1940 [실버4])
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N, M;
    long sum;
    long count = 0;
    cin>>N>>M;
    long arr[N];
    for (int i=0; i<N; i++){
        cin>>arr[i];
    }
    sort(arr, arr+N);
    long A=0, B=N-1;
    while(A<B) {
        sum = arr[A]+arr[B];
        if (sum>M){
            B--;
        } else if (sum<M){
            A++;
        } else {
            count++;
            A++;
            B--;
        }
    }
    cout<<count;
    return 0;
}
```
![image](https://github.com/ChaeDoll/TIL/assets/108540812/b9be5b60-d003-4939-9d09-f35b16debd91)
갑옷을 조합해서 수를 만드는 것.
1) 우선 배열을 정렬해주어 오름차순으로 둔다. 두개의 갑옷의 고유값을 더하여 M인지를 판단하는 것이기에 번호가 가장 낮은 것, 높은 것. 두 부분에 포인터를 둔다.
2) 이후 두 위치의 값을 더했을 때 M보다 크면 높은값 포인터를 낮추고, M보다 작아지면 낮은값 포인터를 높인다. 이렇게 차츰 범위를 줄여가며 계산한다.
3) 만약 두 포인터의 합이 M값이라면 낮은값 포인터를 높이고 높은값 포인터는 낮추면 된다. 둘 중 하나만 움직여도 되지만, 어차피 이후에 다른 포인터의 움직임이 필요로해진다. 예를 들면 3와 7이 합이라 M값인 10이 된다고 했을 때, 7을 6으로 낮추면 어차피 M값 보다 작은 9가 되기에 낮은 포인터도 올려야하는 상황이 생긴다. 이처럼 어차피 일어날 것이기에 낮은 포인터와 높은 포인터를 동시에 움직이는 것이다.
4) 이렇게 범위를 좁혀가다가 낮은값 포인터가 높은값 포인터보다 위치가 높거나, 혹은 같은 위치에 있다면 종료한다. (더 나가면 중복값이 됨)

- #### 좋은 수 구하기
```
// '좋은 수' 구하기 - 실패코드
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    long arr[N];
    for (int i = 0; i < N; i++) {
        cin>>arr[i];
    }
    sort(arr, arr+N);
    long count = 0;
    for (int i=2; i<N; i++){
        long A = 0;
	    long B = i-1;
        while(A<B){
            long sum = arr[A]+arr[B];
            if (sum < arr[i]){
                A++;
            } else if (sum > arr[i]){
                B--;
            } else {
                count++;
                break;
            }
        }
    }
    cout<<count;
    return 0;
}
```
위 방법대로 풀었었는데 아예 접근을 잘못했나보다. 나는 어차피 오름차순으로 정렬하기도 하니까, 아래부터 위로 올라오면서 좌측에 있는 수들 중 두 개의 합이 Target숫자와 일치하면 count를 1씩 증가시키려했다. 이 방법이 되지 않았고.. 일단 책에 있는대로 문제를 해결했다. 3일차 발표자에게 질문해야겠다.
```
// 문제008 - '좋은 수' 구하기 (백준 1253 [골드4])
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long N;
    cin>>N;
    long arr[N];
    for (int i = 0; i < N; i++) {
        cin>>arr[i];
    }
    sort(arr, arr+N);
    long count = 0;
    for (int i=0; i<N; i++){
        long A = 0;
        long B = N-1;
        while(A<B){
            long sum = arr[A]+arr[B];
            if (sum < arr[i]){
                A++;
            } else if (sum > arr[i]){
                B--;
            } else {
                if (A!=i && B!=i){
                    count++;
                    break;
                } else if (A==i){
                    A++;
                } else {
                    B--;
                }
            }
        }
    }
    cout<<count;
    return 0;
}
```

- 자료구조 : 슬라이딩 윈도우 - 2개의 포인터로 범위를 지정하고 해당 범위를 유지한 채 이동하며 문제를 해결하는 자료구조.
- #### DNA 비밀번호
```
// DNA 비밀번호 - 실패 코드 (시간 초과)
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long length, subLength;
    cin>>length>>subLength;
    char arr[length];
    long count = 0;
    for (int i=0; i<length; i++){
        cin>>arr[i];
    }
    long A, C, G, T;
    cin>>A>>C>>G>>T;
    long AA, CC, GG, TT;
    for (int i=0; i<=length-subLength; i++){
        AA=0, CC=0, GG=0, TT=0;
        for (int j=i; j<i+subLength; j++){
            if (arr[j]=='A') {
                AA++;
            } else if (arr[j]=='C'){
                CC++;
            } else if (arr[j]=='G'){
                GG++;
            } else if (arr[j]=='T'){
                TT++;
            }
        }
        if (AA>=A && CC>=C && GG>=G && TT>=T) count++;
    }
    cout<<count;
    return 0;
}
```
위 방법은 시간복잡도를 만족시키지 못하여 실패한 코드이다. 현재 O(N^2)의 시간 복잡도를 가진 코드인데, 데이터의 크기가 최대 100만이다. 2초라는 시간제한이 걸려있기에, n^2이면 시간 초과할 수 밖에 없었다. 슬라이딩 윈도우(투포인터)를 활용해서 다시 로직을 설계한다. 
```
// 문제009 - DNA 비밀번호 (백준 12891 [실버5])
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    ios_base::sync_with_stdio(false); // 입출력 동기화 비활성화
    cin.tie(NULL); // cin과 cout의 묶음을 해제
    long length, subLength;
    cin>>length>>subLength;
    char arr[length];
    long count = 0;
    for (int i=0; i<length; i++){
        cin>>arr[i];
    }
    long A, C, G, T;
    cin>>A>>C>>G>>T;
    long start = 0;
    long end = subLength-1;
    long AA, CC, GG, TT;
    AA=0,CC=0,GG=0,TT=0;
    for (int i=0; i<subLength; i++){
        if (arr[i]=='A') {
            AA++;
        } else if (arr[i]=='C'){
            CC++;
        } else if (arr[i]=='G'){
            GG++;
        } else if (arr[i]=='T'){
            TT++;
        }
    }
    if (AA>=A && CC>=C && GG>=G && TT>=T) count++;
    while(end<length-1){
        start++, end++;
        if (arr[end]=='A') {
            AA++;
        } else if (arr[end]=='C') {
            CC++;
        } else if (arr[end]=='G') {
            GG++;
        } else if (arr[end]=='T') {
            TT++;
        }
        if (arr[start-1]=='A') {
            AA--;
        } else if (arr[start-1]=='C') {
            CC--;
        } else if (arr[start-1]=='G') {
            GG--;
        } else if (arr[start-1]=='T') {
            TT--;
        }
        if (AA>=A && CC>=C && GG>=G && TT>=T) count++;
    }
    cout<<count;
    return 0;
}
```

이전에는 이중 for문으로 시간복잡도가 O(N^2)이었지만, 이제는 슬라이딩 윈도우를 통해 맨 앞과 맨 뒤, 두개의 값만 연산하여 시간복잡도를 대폭 감소시켜 O(N)의 시간복잡도를 가지게 할 수 있었다.
### 4일차
- 자료구조 : 스택과 큐
### 5일차
- 정렬 : 버블 정렬
- 정렬 : 선택 정렬
### 6일차
- 정렬 : 삽입 정렬
- 정렬 : 퀵 정렬
