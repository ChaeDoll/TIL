## 섹션7 복습  
### 의존관계 주입 - 생성자 주입의 장점  
이전에 보았던 주입들 중에 생성자 주입을 쓰는 것을 권장한다.  
왜냐면 대부분의 경우에 의존관계를 변경할 일이 솔직히 없다. 오히려 변하면 안되는 경우가 더 많음  
따라서 변경이 쉬운 설계 방식은 그렇게 좋은 방법이 아니라는 것이다.  
생성자 주입을 사용하면 코드 형태만 보아도 테스트를 짜는데 간단하게 조립할 수 있다. 필요한 정보를 뽑기가 쉬움  
수정자 주입에 경우엔 주입되는 값이 누락된 경우 어디에서 누락이 되었는지 확인하기 어려운데 생성자 주입은 누락된 위치를 바로 오류로 알려준다.  
또한 불변하기 때문에 final 키워드를 사용할 수 있다는 장점도 있다.  
생성자에 코드 누락이 있다면 final 키워드에서 컴파일 오류가 난다.  
오류 중에 제일 좋은게 컴파일 오류!! 고치기 쉽고 간단 명료하게 지적해준다.  
> 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.  

프레임워크에 의존 안하고 순수한 자바 언어의 특징을 사용할 수 있는 방식이 '생성자 주입 방식' 이다.  
잘 활용하는 방법은 생성자 주입방식을 주로 삼고, 변경 가능성이 있는 경우에는 옵션으로 수정자 주입방식을 사용하면 된다.  
그니까 결국엔, 생성자 주입 방식을 사용해라!  

### 롬복과 최신 트렌드  
생성자 주입은 다 좋은데 코드가 귀찮다. 생성자도 만들어야하고 대입하는 코드도 만들어야함  
일단 build.gradle에 롬복 라이브러리 설정을 추가한다.  
그리고 설정에서 Annotation process를 켜둔다. 이러면 Intellij에서 롬복 사용가능해짐  
롬복의 대표 기능? => 클래스 메소드에 애노테이션으로 @Getter이나 @Setter를 붙이기만 하면 Getter와 Setter를 자동으로 만들어준다.  
그래서 우리는 setXxx이나 getXxx 같은것을 사용가능해진다. 코드가 간결해진 것!  
실무에서 정말 많이 사용한다.  
@ToString이라는 것도 쓰면 알아서 ToString이 구현된다. 우리는 print(객체명)만 해도 되는것  
@RequireArgsConstructor 을 사용하면 final이 붙은 필드를 모아서 필요한 생성자를 알아서 만들어준다.  
가끔 생성자가 직접 필요한 경우 어쩌다 있는데, 그럴 때만 직접 만들고 웬만한 경우 이 방식을 사용한다.  
의존관계 추가할 때 굉장히 편리하다. final이 붙은 코드 한 줄만 추가하면 되니까  
최근엔 생성자를 1개 두고 @Autowired를 생략하는 방식을 많이 쓰는데 Lombok 라이브러리까지 쓰면 더 생략이 가능한 것이다.  
@RequireArgsConstructor 이 생성자를 다 만들어준다.  

### 조회 빈이 2개 이상일 때 문제해결 방법  
우선 쉽게 이것을 설명하기 위해 위에서 만든 @RequireAr...를 다시 원상복구한다.  
컴포넌트 스캔으로 빈을 조회할 때 생성하는 매개변수 타입으로 의존관계를 자동 주입해준다.  
그런데 만약 같은 타입을 갖는 빈이 2개가 있다면 자동으로 주입하는 데에 오류가 생긴다.  
둘 중 하나가 주입되는 것이 아닌, 오류로 두개가 조회되었다고 알려준다.  
수동 주입으로 해결할 수도 있지만 자동 주입에서 해결하는 방법이 있으니...  

### @Autowired 필드명, @Qualifier, @Primary  
@Autowired가 붙은 메소드에서 필드명을 애초에 의존관계로 주입되길 원하는 필드명으로 지정한다.  
타입이 똑같아도 지정된 이름의 필드를 가져오는 것이다.  
@Qualifier("구분명")의 방식으로도 가능하다.  
이 애노테이션은 '추가구분자'로서, @Component로 지정되는 클래스에 같이 붙이고 동일한 코드를 의존관계 주입을 원하는 매개변수들 앞에 붙여주면 된다.  
이러면 구분자가 붙어있는 생성자 혹은 수정자들이 같은 이름의 구분자가 붙은 컴포넌트빈에 의존관계를 연결한다.  
만약 같은 이름의 구분자를 못찾으면 구분명과 동일한 이름의 스프링 빈을 찾아서 연결한다.  
물론 못찾았을 때의 이야기고 딱 @Qualifier는 @Qualifier를 찾는 용도로만 쓰는 것이 좋다. 헷갈리게 하지 말자  
마지막으로 @Primary를 붙여서 우선적으로 매칭되도록 하는 방법도 있다.  
여러개의 빈이 매칭되었을 때 @Primary가 붙은 빈과 매칭된다.  
@Qualifier은 다 좋은데 일일이 사용되는 애들에 다 붙여야해서 너무 귀찮다.  
일단 우선순위는 Qualifier가 Primary보다 더 높다. 더 상세한게 우선  

### 위 방법이 맘에 안들면 직접 애노테이션을 만들면 된다.  
애노테이션을 생성하는 방법은 알고 있을 것이다.  
@interface의 방식.  
여기 설정에 @Qualifier("구분자 명")을 붙여서 그냥 앞으로는 새로 만든 애노테이션만 붙여주면 자동으로 @Qualifier("구분자 명")이 붙어있는 것이나 다름 없는 것이다.  
사용 방법은 @Qualifier과 동일하나 직접 애노테이션을 만들면, 컴파일시에 타입 체크가 가능할 것이다.  
왜냐면 Qualifier이 여러개 다른 구분자명으로 존재해도 결국 타입은 @Qualifier이지 구분자명이 아니다.  
반면 새롭게 애노테이션을 생성하면 새롭게 만든 애노테이션이 곧 타입이 된다.  
제너릭 메소드와 같은 방식으로 이해하면 될 듯.  
이게 상속처럼 보일 수 있는데 상속은 아니다. 그냥 여러 애노테이션을 모아서 사용하는 스프링의 기능이다.  

### 조회 빈이 모두 필요할 때?

### 자동 수동의 올바른 실무 운영 기준  


