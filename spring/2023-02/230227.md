## 섹션7 복습  
### 의존관계 주입 - 생성자 주입의 장점  
이전에 보았던 주입들 중에 생성자 주입을 쓰는 것을 권장한다.  
왜냐면 대부분의 경우에 의존관계를 변경할 일이 솔직히 없다. 오히려 변하면 안되는 경우가 더 많음  
따라서 변경이 쉬운 설계 방식은 그렇게 좋은 방법이 아니라는 것이다.  
생성자 주입을 사용하면 코드 형태만 보아도 테스트를 짜는데 간단하게 조립할 수 있다. 필요한 정보를 뽑기가 쉬움  
수정자 주입에 경우엔 주입되는 값이 누락된 경우 어디에서 누락이 되었는지 확인하기 어려운데 생성자 주입은 누락된 위치를 바로 오류로 알려준다.  
또한 불변하기 때문에 final 키워드를 사용할 수 있다는 장점도 있다.  
생성자에 코드 누락이 있다면 final 키워드에서 컴파일 오류가 난다.  
오류 중에 제일 좋은게 컴파일 오류!! 고치기 쉽고 간단 명료하게 지적해준다.  
> 오직 생성자 주입 방식만 final 키워드를 사용할 수 있다.  

프레임워크에 의존 안하고 순수한 자바 언어의 특징을 사용할 수 있는 방식이 '생성자 주입 방식' 이다.  
잘 활용하는 방법은 생성자 주입방식을 주로 삼고, 변경 가능성이 있는 경우에는 옵션으로 수정자 주입방식을 사용하면 된다.  
그니까 결국엔, 생성자 주입 방식을 사용해라!  

### 롬복과 최신 트렌드  
생성자 주입은 다 좋은데 코드가 귀찮다. 생성자도 만들어야하고 대입하는 코드도 만들어야함  
일단 build.gradle에 롬복 라이브러리 설정을 추가한다.  
그리고 설정에서 Annotation process를 켜둔다. 이러면 Intellij에서 롬복 사용가능해짐  
롬복의 대표 기능? => 클래스 메소드에 애노테이션으로 @Getter이나 @Setter를 붙이기만 하면 Getter와 Setter를 자동으로 만들어준다.  
그래서 우리는 setXxx이나 getXxx 같은것을 사용가능해진다. 코드가 간결해진 것!  
실무에서 정말 많이 사용한다.  
@ToString이라는 것도 쓰면 알아서 ToString이 구현된다. 우리는 print(객체명)만 해도 되는것  
@RequireArgsConstructor 을 사용하면 final이 붙은 필드를 모아서 필요한 생성자를 알아서 만들어준다.  
가끔 생성자가 직접 필요한 경우 어쩌다 있는데, 그럴 때만 직접 만들고 웬만한 경우 이 방식을 사용한다.  
의존관계 추가할 때 굉장히 편리하다. final이 붙은 코드 한 줄만 추가하면 되니까  
최근엔 생성자를 1개 두고 @Autowired를 생략하는 방식을 많이 쓰는데 Lombok 라이브러리까지 쓰면 더 생략이 가능한 것이다.  
@RequireArgsConstructor 이 생성자를 다 만들어준다.  

### 조회 빈이 2개 이상일 때 문제해결 방법  
우선 쉽게 이것을 설명하기 위해 위에서 만든 @RequireAr...를 다시 원상복구한다.  
컴포넌트 스캔으로 빈을 조회할 때 생성하는 매개변수 타입으로 의존관계를 자동 주입해준다.  
그런데 만약 같은 타입을 갖는 빈이 2개가 있다면 자동으로 주입하는 데에 오류가 생긴다.  
둘 중 하나가 주입되는 것이 아닌, 오류로 두개가 조회되었다고 알려준다.  
수동 주입으로 해결할 수도 있지만 자동 주입에서 해결하는 방법이 있으니...  

### @Autowired 필드명, @Qualifier, @Primary  
@Autowired가 붙은 메소드에서 필드명을 애초에 의존관계로 주입되길 원하는 필드명으로 지정한다.  
타입이 똑같아도 지정된 이름의 필드를 가져오는 것이다.  
@Qualifier("구분명")의 방식으로도 가능하다.  
이 애노테이션은 '추가구분자'로서, @Component로 지정되는 클래스에 같이 붙이고 동일한 코드를 의존관계 주입을 원하는 매개변수들 앞에 붙여주면 된다.  
이러면 구분자가 붙어있는 생성자 혹은 수정자들이 같은 이름의 구분자가 붙은 컴포넌트빈에 의존관계를 연결한다.  
만약 같은 이름의 구분자를 못찾으면 구분명과 동일한 이름의 스프링 빈을 찾아서 연결한다.  
물론 못찾았을 때의 이야기고 딱 @Qualifier는 @Qualifier를 찾는 용도로만 쓰는 것이 좋다. 헷갈리게 하지 말자  
마지막으로 @Primary를 붙여서 우선적으로 매칭되도록 하는 방법도 있다.  
여러개의 빈이 매칭되었을 때 @Primary가 붙은 빈과 매칭된다.  
@Qualifier은 다 좋은데 일일이 사용되는 애들에 다 붙여야해서 너무 귀찮다.  
일단 우선순위는 Qualifier가 Primary보다 더 높다. 더 상세한게 우선  

### 위 방법이 맘에 안들면 직접 애노테이션을 만들면 된다.  
애노테이션을 생성하는 방법은 알고 있을 것이다.  
@interface의 방식.  
여기 설정에 @Qualifier("구분자 명")을 붙여서 그냥 앞으로는 새로 만든 애노테이션만 붙여주면 자동으로 @Qualifier("구분자 명")이 붙어있는 것이나 다름 없는 것이다.  
사용 방법은 @Qualifier과 동일하나 직접 애노테이션을 만들면, 컴파일시에 타입 체크가 가능할 것이다.  
왜냐면 Qualifier이 여러개 다른 구분자명으로 존재해도 결국 타입은 @Qualifier이지 구분자명이 아니다.  
반면 새롭게 애노테이션을 생성하면 새롭게 만든 애노테이션이 곧 타입이 된다.  
제너릭 메소드와 같은 방식으로 이해하면 될 듯.  
이게 상속처럼 보일 수 있는데 상속은 아니다. 그냥 여러 애노테이션을 모아서 사용하는 스프링의 기능이다.  

### 조회 빈이 모두 필요할 때?  
할인에 관해서 클라이언트가 할인 혜택을 직접 '선택'하는 방식에서는 동일한 타입의 빈이 두개 이상 필요할 것이다.  
위에서는 두개 이상 있을 때 오류가 생기지 않도록 하는 방법이었는데, 이걸 넘어서 둘 다 사용하는 상황에서는 다른 방법이 있다.  
바로 타입 자체를 맵 혹은 리스트로 생성하는 방식이다.  
이로 인해 하나씩 매핑되는 방식이 아니라 여러개의 대상을 모두 주입받을 수 있고 어떤 코드를 넘겨받냐에 따라서 그에 맞는 스프링빈을 실행시키는 방식으로 가능하다.  

### 자동 수동의 올바른 실무 운영 기준  
쉽게 정리해보면 점점 실무에서는 자동을 추구하는 추세이다.  
업무로직에 있어서는 기본적으로는 자동을 기본으로 한다.  
기술지원에 있어서는 기술적 문제나 공통 관심사, 또한 데이터베이스 연결이나 공통 로그처럼 업무로직을 지원하는 기술에 있어서는 어디에서 문제가 발생하는지 개발자들이 잘 파악할 수 있도록 수동으로 하는것이 권장된다.  
즉, 애플리케이션 전반적으로 넓은 영역에 영향을 끼치는 중요한 기술지원 객체는 수동으로 등록하여 설정정보를 명확하게 볼 수 있도록 한다.  
그 외 코드의 거의 대부분은 자동으로 한다고 보면 된다.  
보통 비즈니스 요구사항을 다루는 것들은 업무로직 쪽이다.  

수동등록으로 설정정보에 바로 나타나게 하면 개발자들도 '이게 매우 중요한 로직이구나' 판단할 수도 있다.  
근데, 업무로직(비지니스 로직)에서도 다형성을 사용하는 경우에는 수동으로 등록하기도 한다.  
조회한 빈이 모두 필요한 경우를 예시로 들어보면 된다.  
자동으로 등록되는 경우 조회한 빈들이 무엇들이 있고 어떤 것이 주입되는지 한눈에 알기는 어렵다.  
하지만 수동으로 등록했다면 설정정보를 통하여 바로 어떠한 것들이 빈으로 존재하고 같은 타입으로 입력될 예정이라는 것을 확인가능하다.  
이런 경우에도 수동등록이 좋을 수 있다. 물론 자동도 가능  
만약 자동으로 한다하면 헷갈리지 않게 특정 패키지에 함께 묶어두는게 좋겠죠?  
> 편리한 자동 기능을 기본으로 사용  
직접 등록하는 기술 지원 객체는 수동 등록  
다형성을 적극 활용하는 비지니스 로직은 수동 등록을 고민  

## 섹션8 복습 - 빈 생명주기 콜백  
