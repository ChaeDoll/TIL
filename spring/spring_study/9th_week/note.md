# 9주차 내용정리  

## 섹션6  
### 컴포넌트 스캔  
지금까지는 @Bean이나 XML의 <bean>을 통해 등록했음.  
우리가 한 것은 얼마 안되는 개수였지만 빈이 많아질수록 등록도 귀찮고 설정도 커지고 누락되기도 함. 반복 작업은 싫다.  
새롭게 AutoAppConfig를 만들 예정이다.  
@ComponentScan이라는 것을 @Configuration 아래에 작성하면 자동으로 등록하는 기능이 탑재된다.  
여기서 필터기능을 넣어서 뺄 것을 지정한다.  
이렇게 하면 @Bean으로 등록한 것이 하나도 없는 상태이다.  
Configuration도 Component로 등록되어 있어서 필터 기능으로 예외처리 한 것이다. 예외처리 안해도 되는데 이전의 코드를 유지하기 위해서...   
컴포넌트 스캔이란 무엇이냐, 말 그대로 @Component가 붙은 클래스를 스캔하여 스프링빈으로 등록하는 것  
이제 각 클래스에 컴포넌트스캔 대상이 되도록 @Component 애노테이션을 붙여준다.  
그런데 의존관계가 생성 안되지 않느냐? @Autowired를 사용하여 의존관계를 자동으로 연결해준다.  
스캔, 의존관계 주입이 어떻게 동작하냐면..  
컴포넌트스캔이 우선 @Component가 붙은 모든 클래스를 스프링빈으로 먼저 등록한다.  
이 때, 빈 이름은 객체클래스명을 사용하여 등록한다. 맨 앞글자만 소문자로 바꿔서!  
즉 MemberServiceImpl의 클래스는 빈으로 등록되면 memberServiceImpl로 등록됨  
빈 이름을 직접지정도 가능한데, @Component("memberService2") 이런식으로 직접 등록 가능  
@Autowired를 사용해 의존관계를 지정하는 방법은, 먼저 @Autowired를 생성자에 지정되면, 그 생성자의 매개변수(타입)를 갖는 스프링빈을 찾아서 주입시킨다.  
그럼 같은 타입이 여러개면? -> 충돌이 날 것이다. 이후 자세하게 설명  
getBean(MemberRepository.class)를 사용하는 것과 동일하다고 이해하면 된다.  
매개변수가 여러개인 것은 문제가 없다. 다 찾아준다. 하지만 같은 타입이 여러개 발생하면 그게 문제인 것이다. 제대로 구분하길!  
사실, 모든 자바 클래스를 탐색하면 시간이 꽤나 걸릴 것이다. 따라서 컴포넌트 범위를 설정할 수도 있다.  
@ComponentScan 뒤에 괄호를 사용하여 basePackages = "hello.core"과 같은 형태의 코드를 작성하면 시작 탐색 위치가 hello.core부터 시작된다.  
시작 위치를 여러개 지정할 수도 있다. 지정하지 않으면 @ComponentScan이 적힌 클래스가 존재하는 패키지가 시작위치가된다.  
시작위치를 설정하는 것도 좋지만, 사실 설정 정보 클래스를 최상단에 두는 것을 더 많이 쓰는 듯 하다.  
스캔 대상은 @Component 뿐만 아니라 @Controller @Service @Repository @Configuration 이 모든 것들이 스캔 대상이다. @interface 에 Controller, Service ...등이 인터페이스로 존재하고 그것들이 Component 등록이 되어있는 소스코드가 내포되어 있다.  
컴포넌트 스캔 필터로 excludeFilters를 썼었는데 includeFilters라는 것도 존재한다.  
필터타입은 5가지가 있는데 ANNOTATION(기본값, 어노테이션), ASSIGNABLE_TYPE(지정한 타입과 그 자식타입), ASPECTJ(AspectJ 패턴), REGEX(정규 표현식), CUSTOM(TypeFilter라는 인터페이스 구현하여 처리)가 있다.  
includeFilters는 잘 사용안하고 excludeFilters는 가끔 쓸일이 있지만 자주쓰진 않는다.  

컴포넌트 스캔으로 이름이 같은 빈을 받으면 오류가 난다. 수동빈과 자동빈을 선언하면 수동빈이 우선권을 가지고 자동빈을 오버라이딩 해버린다.  


## 섹션7  
### 의존관계 자동 주입  
의존관계 주입은 생성자 주입, 수정자 주입(setter), 필드 주입, 일반 메소드 주입 크게 4가지가 있다.  
차례대로 설명을 해보면,  
생성자 주입 - 불변, 필수 의존관계에 쓰이며 생성자 호출시점에 딱 1번 호출되는 것 보장된다. 
생성자가 딱 1개만 있다면 @Autowired를 생략해도 자동으로 주입된다. (스프링빈 기준)  
수정자 주입 - 선택, 변경 가능성이 있는 의존관계에 쓰이며 필드 값을 변경하는 setter 메소드를 사용하여 의존관계를 주입하는 방식이다.  
참고로 @Autowired는 주입 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도 동작하기 위해선 required=false로 설정해두자. 관련 내용 : 자바빈 프로퍼티  
필드 주입 - 말 그대로 필드에 바로 주입하는 방식이다.  
코드가 간결하여 끌리기 쉽지만 외부에서 변경이 불가능하고 테스트하기 어렵다는 단점이 있다. 사용하지 말아야할 방식이다.  
이는 실제 코드랑은 관계없는 테스트코드, 스프링 설정을 목적으로하는 @Configuration과 같은 특수 상황에서만 쓰인다.  
일반 메소드 주입 - 일반 메소드를 사용하여 주입 받는 방식이다. 한번에 여러 필드를 주입 받을 수 있고 일반적으론 잘 쓰이지 않는다.  
가끔은 주입할 스프링 빈이 없어도 동작해야할 때가 있다.  
@Autowired는 대상이 없으면 오류가 발생하기에 required=false를 설정하기도 한다 했는데, 이 방식은 대상이 없으면 아예 메소드 자체가 호출이 안된다.  
호출이 되면서도 대상이 없다면 없다고 인지할 수 있게 하는 방식이 있으니..  
@Nullable 혹은 Optional<>을 사용하는 방식이다.  
Nullable은 자동 주입 대상이 없으면 null값이 입력되는 방식이고, Optional은 대상이 없으면 Optional.empty가 입력된다.  
위 두 기능은 스프링 전반에 걸쳐 지원된다. 특정 필드에만 사용해도 됨  
이렇게 네 가지의 의존관계 자동 주입을 알아봤는데, 권장하는 방식은 '생성자 주입 방식'이다. 스프링을 포함하여 최근 DI 프레임워크 대부분이 생성자 주입 방식을 권장한다.  
불변한다는 장점. 어차피 대부분의 의존관계는 애플리케이션 종료까지 한번 설정되면 변경할 일이 없기에 오히려 변하면 안되는 상황이 더 많다.  
또한 수정자 주입으로 설정하기 위해선 public으로 메소드를 열어야하기에 보안상으로도 아쉽다.  
변경하지 않아야하는 메소드를 public으로 두는 것은 불안하기 마련  
반면 생성자 주입은 객체 생성 시에 딱 한번만 호출되기에 불변성을 지키기 좋다.  
생성자 주입을 사용하면 필드에 final을 사용가능하다.  
이는 생성자에서 혹시라도 값이 설정되지 않는 오류를 빠르게! 컴파일 시점에서 막아준다.  
컴파일 시점의 오류가 세상에서 가장 빠르고 다루기 쉬운 오류이다!  
생성자 주입 외에 다른 방식들은 final을 사용할 수 없다. 오직 생성자 방식만 가능  
프레임워크에 의존하지 않고, 순수 자바 언어 특징을 잘 살리는 방식이기도 하다.  
기본으로 생성자주입방식. 필요에 따라 수정자주입방식으로 옵션 부여 하는 방식도 좋다. 이 둘은 함께 사용이 가능하기에..  

### 롬복, 최신트렌드  
필드 주입처럼 편하게 개발할 수는 없을까  
롬복 라이브러리를 사용하여 @RequiredArgsConstructor를 사용하면 final이 붙은 필드를 모두 모아 생성자를 자동생성 해준다.  
간결하게 코드를 정리할 수 있게된 셈  
롬복이 '컴파일 시점'에서 생성자 코드를 자동생성 해준다.  
최근에는 생성자를 딱 1개 두고(Autowired 생략 가능) 롬복 라이브러리의 위 어노테이션 기능을 사용하여 코드를 깔끔히 하는게 주로 사용하는 방법이다.  
롬복 라이브러리는 build.gradle에 설정을 추가하기만 하면 된다.  
