## 섹션 9 이어서..  
### 프로토타입과 싱글톤 빈을 함께 사용할 시 발생하는 문제  
그러면 프로토타입과 싱글톤을 함께 쓰면 어떠한 문제가 생기는가?  
우선 클라이언트가 프로토타입빈을 요청하고 그 내부에 count라는 필드가 있으며 빈이 생성된 이후 1씩 올라가도록 설정한다.  
프로토타입 빈의 경우엔 당연하게도 1번 빈과 2번 빈의 count값이 둘 다 1일 것이다.  
하지만 여기에서 싱글톤에서 프로토타입의 빈을 사용하는 상황을 추가해본다..  
싱글톤의 클라이언트 빈이 의존관계로서 프로토타입 빈을 호출한다면 주입 시점에 컨테이너에 프로토타입 빈을 요청할 것이다.  
그렇게 만들어진 프로토타입 빈은 클라이언트 빈에 반환되어 클라이언트 빈(싱글톤)이 관리한다.  
이제 클라이언트 빈이 내부에 프로토타입 빈을 보관한다.  
여기에서 클라이언트가 싱글톤의 클라이언트 빈을 통해 로직을 요청하고, 싱글톤의 특성 상 같은 빈을 반환받는다.  
위에있는 count 예시로 생각해보면, 싱글톤 클라이언트 빈은 클라이언트에게 로직(addCount)을 요청받으면 DI되어 가지고있던 프로토타입 빈의 내부에 있는 count값을 0->1로 증가시킬 것이다. 그리고 그 값을 클라이언트에게 반환할 것이다.  
그런데! 여기서 다른 클라이언트가 클라이언트 빈에서 addCount를 요청하는 상황이 생길 수 있다.  
문제는, 두 번째 클라이언트는 프로토타입 빈을 기대하여 addCount를 최초로 요청했으니 0->1의 count값을 기대할 것이다.  
하지만 싱글톤 클라이언트의 특성 상 같은 빈을 사용하기 때문에 이미 DI 되어있는 프로토타입 빈에 연결되어있어 1->2의 count값을 반환받게 된다.  
즉, 프로토타입 빈을 사용했지만 사실 상 프로토타입의 역할을 하지 않는다.  
아마 사용할 때마다 새로 생성하여 사용하는 방식을 원해서 프로토타입을 사용했을 것이다.  
물론 가능은 하다. 클라이언트 빈에 있는 로직 메소드 내부에 프로토타입 빈을 getBean을 하는 방법도 있긴 하다... 근데 좋은 코드는 아니다. 너무 스프링 의존적임  



## 섹션 10 - 다음으로  
