### 데보션 오픈랩 후기
2024.04.22 ~ 07.21 (3개월) 동안 실시한 10가지의 스터디.
하반기에도 또 시행할 예정임.
OpenLab OpenAPI... 이런 Open이라는 말들이 왜 나오기 시작했나? 전통적인 기업의 분위기에서 조금 더 개방적인 패러다임으로 나타난 개념이다.

10개의 스터디 모임, 102명의 개발자, 118건의 블로그
여기에 9개 세션/4개 포스터 . 프로젝트 부스도 있다.

OpenLab을 한 102명에게 피드백을 하면 **4.65/5.0**이었다. 다음 스터디 참여에 모두 다시하고싶다는 피드백이 있었다.
**좋았던 점**
- 현업 개발자와 함께 하기에.. 다양한 배경과 경험 가진 분들과 함께하여 더욱 다양한 관점에서 바라볼 수 있음.
- 퇴근 후의 자유로운 토론
- 현업에서의 고급기능, 실무운영 팁 등
- 스터디 운영자님들의 열정/노력
**개선할 점**
- 난이도 문제
- 장소, 온도 문제
- 오프라인 참여의 문제
- 식사 제공 여부, 쉬는 시간 등 사전 공지

6회째의 Tech Day 행사이다. 지금까지는 반나절밖에 안해서 TechDay라기에 애매했지만, 이번에는 10:00부터 18:00까지라 진짜 Tech Day이다
11시 40분쯤부터 점심시간 - 13:30부터 Part2 / 15시쯤부터 15:30까지 쉬는시간

**프로젝트 데모 부스**
Echo-Teddy
Lens
LLMEdubank
TGO(Travel GO)
직접 참여해봅시다.

# 목차
1) 개발자가 알아야 할 NAT, DNS
2) GraphRAG로 여행 100% 준비하고 떠나기
3) AI Travel Agent, Travel GO
4) 나는 왜 코프링 컨트롤러를 더 이상 만들지 않게 되었나?
5) SQL 쿼리 작성, 이제는 쉽고 빠르게 LENS
6) Kubeflow 알아보기
7) 대규모 시스템 첫걸음
8) C++ 개발자가 바라보는 Rust
## 1) 개발자가 알아야 할 NAT, DNS
**인프라 엔지니어 : 고재민**
DNS 동작방식과 도메인 위임, NAT 동작방식과 방화벽.. 
#### DNS란? Domain Name Service
- 사람이 읽을수있는 도메인 이름을 컴퓨터가 읽을 수 있는 IP주소로 변환하는 것.
- 클라우드 기반 인프라 구성이 많아지며 인프라가 빈번히 변경되어 DNS를 이용한 시스템 설계가 중요해지고 있음
- IP를 이용한것보다 도메인으로 많이 하고있음 (IP는 자주 변경될수있으니..)

blog. example. com.은
sub/second-level/top-level/root 순서이다.

**ipconfig/displaydns** : dns정보 확인가능
**ipconfig/flushdns** : 기존 로컬 DNS캐시를 비우고 새로운 도메인 정보를 가져올 수 있음 

Local에서 DNS 서버 요청을 보내고, DNS에서 해당 주소를 Root, Top-name, Cloud 순서로 탐색한다?

Local 캐시에 저장이 되어있는지 확인하고, 있다면 DNS서버는 바로 해당 웹사이트를 전달하고, DNS서버에서 해당 도메인 정보가 없다면 루트네임-탑레벨도메인-클라우드 순서로 
.com / example.com / blog.example.com 인가?

DNS 동작방식은 TTL과 DNS
- TTL이 짧을수록 도메인이 바뀌었을 때 이를 PC가 알아차리는 속도가 빠르다. 업데이트시에는 TTL설정을 짧게하고, 자주바뀌지 않는 도메인이면 TTL을 길게 변경할 수 있다.
- 하지만 쿼리를 자주해야하기에 DNS 서버에 부하가 증가한다. TTL이 길면 쿼리 자주 안해도 되지만 도메인 정보가 바뀌었을때 이를 알아차리지못함

**DNS 도메인 위임**
상위 도메인에서 하위 도메인의 네임서버를 지정하여 관리권한 넘겨주는것을 의미.
- 도메인을 위임하면 AWS, NCP 서로 다른 플랫폼으로도 사용할 수 있는것. 별도 운영 가능

**NAT란? Network Address Translation**
- 사설IP에서 공인IP로, 사설 IP에서 사설IP로, 공인IP에서 공인IP로 모두 NAT이다.
- 가정에서 인터넷을 사용하는 경우가 대표적인 예시이다. (공유기를 통함)
- 인터넷 공유기는 IP와 포트번호를 활용해서 SourceIP/Port 와 Destination IP/Port를 변환하는 테이블을 형성하여 사설주소를 갖는 컴퓨터의 네트워크를 공인IP로 활용하도록 할 수 있는 것.
**AWS에서의 SourceNAT, DestinationNAT**
- 프라이빗 서브넷인 EC2는 외부통신이 막혀있다. 따라서 NAT를 통해(SourceNAT) 외부 망에 연결하는 것이다.
- 로드밸런서를 이용하여 공인IP가 없는 EC2에 도달할 수 있도록 하는 것이 DestinationNAT이다.
**NAT와 방화벽**
- 개발 업무 하다보면 방화벽 신청을 할 때가 있는데, 연결이 되 안되다 할 때가 있다.
- 사내 NAT IP를 미리 파악해서 신청하면 네트워크 문제를 해결할 수 있다.
**정리**
- DNS를 활용한 온프레미스 + 클라우드 운영방법 (GSLB with 재해복구) / 멀티클라우드 환경을 구축할 수 있다.
- MSA, 쿠버네티스 환경에서의 Service Registry, Service Discovery
- DNS A레코드, CNAME 레코드
- NAT 이중화 시 방화벽 허용 잊지마세요.

DNS 위임은 서버 두대가 필요한데, 클라우드 환경에서 하기 좋다.
**질의응답**
1. 방화박 설정만으로도 기본적인 해킹 시도들은 막을 수 있나요? => 기본적으로 리눅스에도 FireWall이라는게있고, AWS에서도 보안그룹이라는게 있다. 해킹시도는 기본적으로 연결이 되어야하는데 SSH는 22번포트를 사용하는데, 특정 포트보다는 이렇게 포트를 변경한다면 좀 안전할 수 있다.
2. **포트포워딩도 NAT 과정인가요?** => 포트포워딩도 어떻게보면 공인IP를 사설IP로 매핑시키는데 어떻게보면 NAT과정이라 생각한다.
3. AWS Route53에 ns는 4가지로 등록되어있었는데, 스크린샷상 타 클라우드 ns에 등록할 때 2개만 등록하신것으로 보였는데, 4가지 모두 등록하지 않아도 문제되지않는지 => 4개가 있어도 각각 동작하는것이기에 전부 등록하지 않아도 각각 잘 동작하게된다.

## 2) GraphRAG로 여행 100% 준비하고 떠나기
**그래프 데이터사이언티스트 : 정이태**
- GraphRAG가 뭐지???
**여행 가기 전 100% 준비하고 있는지?**

고객을 세 분류로 나눈다면.. 혜택을 전혀 활용하지 못하는 고객, 로밍 어느정도 활용하는 고객, 엄청 활용하는 고객 => 왜 이런 고객들의 경우가 나타날까? 편의를 제공해야하는데! 왜 100% 챙겨주고싶어도 잘 안될까?
- 두 세대에게 질문했다. 원인은 무엇이냐..
- **중장년층** : 해외여행 가기전에 로밍 요금제. 114 전화하거나 공항부스 찾아간다. / Q. 인터넷으로도 충분히 가입할수있는데 시도해보겠어요? / 복잡해서 어려워요... 아들에게 부탁할래요 / Q. 혜택 받을수있는거 많아보이는데 활용할수있나요? / 아 그래요? 아들에게 부탁해야겠네
- **청년층** : 혜택을 고루고루 사용하는분 / Q. 어떻게 다 알고 했나? / Q.요금 혜택 이외에도 다른 혜택 모두 사용했는지? / 추가적인 혜택은 설명이 잘 이해가 되지 않아서 하지 않았다. 

두 세대를 아우르는 말. **복잡함**. 둘은 로밍 가입 경로가 다르다.
- 중장년층은 직접 전화 혹은 공항부스 방문. 금전적인것은 생각보다 크게 안고민
- 청년층은 앱으로 가입하고 혜택 적용안됐으면 상품 구매 안했을것이다.

우리가 여행갈때는 고민할것들이 너무 많다. 무슨 요금제쓸지 혜택 유무에 따라 또 달라지고..  혜택을 내가 받을수는 있는지...

내 멤버십 등급에서 이게 가능할지에 대해 고민해야하고.. 기존에 있는 가족결합과 로밍에 있는 가족결합이 별개이고 또 나눠져있는데(한정) 또 혜택 여행지에서 가능한지, 호텔/음식점/쇼핑/관광지/교통 등 어디에 사용가능할지... **너무 복잡하다.**

여행에서는 갈 때 생각할것이 너무 많은데 이것까지 언제 다 신경쓰면서 가는지! 로밍 혜택은 어쩌면 Minor한 부분이다. 그래서 에너지 쓰기 싫을수밖에없다.

**연관지어있는 것들을 연결하여 고객에게 혜택을 쉽게 보여주면 어떨까?**
분리되어 있지만, 사실 모두 연관되어있는 데이터들이다.. 그러면 연결해놓을 수 있다. 혜택들을 모두 연관지어줄수있는것.

로밍 혜택, 고객 정보, 멤버십 혜택 등 다 하나로 통합되어야함.
유저들끼리도 연결되고... 로밍, 멤버십 혜택 등.. 다 연결되고.. 
이런 것들을 **그래프 스키마로 연결한다**

**GraphRAG란??**
LLM계의 오픈북이라고 보면 된다. 책에서 우리가 찾아서 답변을 생성할텐데, LLM이 질문에 답변을하기 위해 데이터를 찾아서 가져와 답변하는것. (환각현상도 감소)
RAG와 GraphRAG의 차이는 가져오느냐 아니냐의 차이?
사용한다면!?
**가족결합 및 유저간 데이터 교류를 확인할 수 있어요.**
가족 결합이 가능한 사람이 누군지, 가족 결합시 얻게 되는 이익이 뭔지, 평소에 데이터를 선물하는 사람은 누구인지 (가족결합 여부 확인, 가족결합 혜택 확인, 평소 데이터 교류 인원 확인)
**여러 혜택을 한번에 알 수 있음**
도쿄로 여행갈 것이다. 라고하면 도쿄로 갈때 받을수있는 혜택을 요약해 볼 수 있음
오키나와의 호텔이나 식당 혜택 알려달라. 하면 해당 내용도 확인가능.  응용가능한 AI답변 가능
**로밍 요금 추천받을 수 있다.**
로밍 요금제 추천해주세요. 라고해도 받을 수 있고, 세부적으로 질문해서 이거랑 이거 차이를 알려달라! 해도 그거에 대해 답변해주고.. DB에 없는 내용은 없으면 없다. 있으면 있다고 얘기할 수 있다. 
실제로 이 요금제 쓰면 얼마정도 나오는지도 연산해서 답변해줄 수 있다. (유저 상황에 맞는 요금제 추천 / 요금제 별 장점 비교 / 평소 데이터 사용량 고려한 예상 요금 제시)

**비즈니스 상품화는 어떻게 가능한가**
고객입장에선 편의성과 가격만족도를 제공하여 고객유지&유치, 가족결합업셀링, 트래픽으로 이어짐.
혜택 제공자(업장) 입장에서는 이로인해 가격 경쟁력, 고객확보, 이는 곧 광고수익, 예약수수료 이익으로 이어짐.
팀마다의 비지니스 구조를 얻어낼 수 있을것으로 예상됨. 

**끝으로..**
AI덕분에 고객 개인니즈, 트렌드 및 비지니스 가속화가 되고있다.
인프라, LLM와 플랫폼 거장들이 말한것은 => 고객 개인화 LLM을 이야기하였다.

**질의응답**
**Q1.** 사용자가 GraphRAG를 활용하려면 직접 지식그래프를 구축할 수 있어야하나요? A. 요즘엔 쉽게 할 수 있다 클릭만으로.
**Q2.** 아들을 시키는것 중장년층 예시분은 여전히 사용안할것같다. A. 굉장히 간편화하면 그래도 사용할것같다.
**Q3.** 지식그래프에서 데이터 검색해 LLM에 넘겨줄 때 어떤 형식으로 넘겨주었나? A. 그래프의 형태를 그대로 넘겨주었다. 질의문을 생성해주는 LLM을 활용해서 그래프 형태로 Context를 넘겨주고 그 그래프를 이해해서 가져온것이다.
**Q4.** 각각의 데이터를 통합하는 과정... 다 그래프가 아니었을것같다. A. 그래프 형태로 만들기 위해 문제정의하는 곳에서 이렇게 연결될것이다! 라는 시멘틱을 만들고 (온톨로지 구축) 한마디로 문제적인 것으로 그래프 구축
**Q5.** 실제 서비스 개발 추론비용이 얼마나들었는지. A.추론 비용은 기껏해야 프롬프트 1000번정도 (1달러정도) 사용했다. 기존에서 Vector Indexing에서 가져오는대비 저렴했다.
**Q6.** 사용한 framework? A.Graph DBMS마다 철학이 다르다.(목적이 다름) 네오포지를 사용하였음. 랭체인도 사용하셨음. 왜 사용해야하는지에 대한걸 먼저 생각하였다.
**Q7.** GraphRAG에서 정보를 더 가져올지말지 결정은 LLM모델이 하나요? A. 어떤 흐름을 타는 라우팅이 중요하다. 하나의 LLM이 하기에 여러 것들을 통합하기에 어려울것인데, 따라서 각각 특화된 LLM을 선택하는과정(라우팅)이 중요하다. (어떤 모델에게 물어볼지) 모델은 GPT-4o모델을 써서 저렴하게 만들었다**.**
**Q8.** GraphDB구성에 비용적인 측면의 효율성? A. 벡터DB로 생각해보면 각각의 사일로마냥 다 비용부담? 그래프DB는 훨씬 저렴하다. Retrieve 소요시간은 1초 안쪽으로 소요된것으로 확인되었다.
**Q9.** GraphRAG 구축 위한 해당 도메인에 Prior Information이 반드시 필요? A. 철학에 따라 다르지만, 반드시 필요하다고 생각한다. 당위성이 있어야하는데, LLM이 이렇게 했다. 는 안된다?
Q10. 그래프 자체를 LLM으로 가져와서 LLM판단에 따라 답변이 나오는것인가요? A.네
Q11. 관리나 업데이트 부담은 어느정도? A. 데이터 통합이 잘 안되어있고 데이터 사일로가 명확하면, 처음 구축만해두면 온톨로지별로 활용가능해서 초반비용만 많이들지 장기적으로 좋다.
업데이트는...그래프DB를 NoSQL을 사용하게 되면 RDBMS, SQLDB에 비하면 간단하다. 부담이 적을것이라 예상된다.
Q12. 한번 질문시 최대 토큰은? 그래프 길어지면 토큰도 클것같다. A. 토큰 어떤LLM이든 Full로 해두고있다. 토큰을 길게해놓고 효율적인 답변을 주는것으로 상쇄할 수 있다고 생각한다. 그래프가 길어지는 경우 **프롬프트엔지니어링** **패스파인딩**을 토대로 질문이 좋은 질문인지 아닌지를 통해 토큰쪽을 활용할 수 있다.

## 3) AI Travel Agent, Travel GO
**여행서비스 스타트업 팀장 : 김하림**
여행준비를 Agent로 해결? 왜 Agent로..?
**LLMOps란?** Large Language Model + Operations
- LLM이 들어간 서비스인데, 처음부터 끝까지 고객한테 전달하고 관리하는 파이프라인을 구축하는것.
- 많은것을 공부해야하는데 RAG, Testing, Fine-tunning, Promp Engineering, Cost Optimization, Monitoring&Observability, Evaluation Metrics 등등...
공부에만 그치지 말고 실제 서비스를 만들어보고자 하였다.

**여행준비 왜 어렵나?**
단계가 정말 복잡하다... 쉽고 간단하지 않다.
- 완벽하고 싶은 욕구 - 여행가면 돈도들고 시간도 든다. 그렇게 제한된 자원에서 완벽하고 행복한 여행을 하고싶은 욕심이 크기 때문이다.  (가고싶은곳과 하고싶은일은 무궁무진) 이를 위해 조사를하는데, 점점 정보가 늘어난다.
- 많은 고객들이 여행 계획을 **노동**처럼 느낀다고 한다. 무려 16~20시간을 사용한다한다. GenZ세대들은 더욱 많이 사용다. 왜? **플랫폼이 다양해져서. 플랫폼마다 특징이 다르다**
- Z세대 여행시 정보탐색을 SNS, 유튜브로 많이하는데 유튜브는 동영상이기에 직관적으로 정보를 얻기 어려움. SNS에서도 바로 원하는정보가 나오지는 않는다. 

**정보 과잉. 선택의 어려움**

**이걸 Agent가 풀 수 있을 것이라 생각했다.**
Agnet란? 주변환경을 인지하고 상호작용하며 목표 달성을 위해 자율적으로 행동하는 시스템
즉, 목표에 맞게 Planning(계획세우기), Tools(어떤 도구를 사용할지; 검색해봐야해 혹은 API를 사용해야해 등), Action(예약같은 실제 행동으로 움직일수있고), FeedBack(지금 내 상황에서 더욱 필요한것을 파악)

하나의 Agent팀으로 구축
- 장소 추천 Agent (DB에 저장된 장소를 바탕으로 추천)
- 질문답변 Agent (신뢰할 수 있는 정보를 바탕으로 유용하고 정확한)
- 일정표 생성 Agent (동선까지 고려된 최적화된 일정 생성 및 맞춤형 체크리스트와 검증된 여행 팁 제공)

User Profile과 함께 Request에서 **숙박하기 좋은 호텔을 추천해주세요!** 라고하면 팀장 역할 Agent가? 장소추천 Agent를 선택한다. 
**장소추천 Agent가** 해당 상황에 맞는 장소를 추천함. (별점 몇점 이상, 후기에 아이가 많은 숙소를 찾아보자; DB와 인터넷검색) (SKT고객이다? 할인혜택은 있을까? GraphRAG 사용)

다음 질문으로 **식당 A에 가려고하는데 예약이 가능한가요?** 가 들어오면, 팀장이 질문답변 Agent로 이어줌. 마찬가지로 UserProfile을 토대로 답변함
질문답변 Agent가 DB&인터넷검색을 토대로 식당A에 대해 찾아보고 답변.. 

Request로 SKT 설립 날짜가 언제인가요? 여행 목적의 LLM이다. 따라서 이러한 목적과 다른 질문이다. 그러면 팀장이 안타깝게도 이 부분에 답변하기 어렵다는 말을 남길 수 있다. => 할루시네이션 방지

Request로 일정표 생성해달라고하면 일정표생성Agent가 이를 답변할 수 있음.

**그럼 결론은... 라우팅역할을 하는 Agent가 있고(팀장), 이들이 여러 LLM 모델들을 연결해주는 느낌 (상담사가 다른 부서로 연결해주듯)으로 활용이 가능하다.**
그러면 만능한 하나의 LLM보다 더욱 현실성있게 똑똑하게 사용가능할듯!
여러개의 특화된 LLM들을 통합하는 느낌?

**질의응답**
Q1. 뜬금없는 질문에 있어서 도움을 줄수없다고 프롬프트엔지니어링으로 응답하는데, 어떤 로직으로 구현가능? A. DB에서 정보를 찾을때 있는지 없는지 확인해서 답장하는것도 가능하고, 팀장Agent가 Classification을 통해 의도를 파악해서 우리가 답장가능한지 판단해서 답변할수도있다.
Q2. 에이전트마다 다른 LLM을 사용했나요? A. 여기서는 다 똑같은 LLM모델로 했는데, 복잡한 답변을 위해선 복잡한 LLM, 빠른답변을 원해선 가벼운LLM을 사용하는 방법도 있다.
Q3. Agent의 상호작용을 프롬프트로 제어하나요? A. agent들이 어떤식으로 상호작용할것인지 workflow를 미리 구축해놓고, 이걸통해 제어한다.
Q4. 에이전트 동작에는 대량의 토큰을 사용할것같은데, 토큰비용절감은 어떻게 고려하는지? A. 토큰을 절약하기보단 성능에 초점을 두려고 했다.
Q5. 처리 시간 지연은 불가피할것같은데 실시간성은 어떻게 확보하나요? A. 데모에서는 다 완성까지 기다리지만, 다음 목표는 실시간성을 보여주려한다.
Q6. 사용자가 답변에 만족하였는지는 어떻게 확인할 수 있나요? A. 고려가 안되어있는데, 후속질문이나 thumbsUP이나 thumbsDown으로 확인할수있게 할수도있다.
Q7. Agent 추천 서비스 가격이 저렴하지 않아 이탈이 일어나는 경엔 어떤식으로 개선할 수 있을까요? A. 고민해보고 올릴게요
Q8. 모호하고 추상적인 질문도 잘 대답하나요? A. 기법이 중요하다. 구체적인 질문으로 바꿔주는 방식으로 활용하면 될 수 있다. 
Q9. 국내와 해외여행지 정보 아우르는 DB구축을 위한 소스가 있었나요? A.힘들게 모아서 공개는 안되겠다 ^^.
Q10. 고객과의 대화 세션을 어느정도 유지? A.아직 메모리기능은..
Q11. 실제 서비스에서 OpenAI API를 활용해도 괜찮나요? 보안문제로 사용하기 어렵지않나요? A.앞으로 개선적으로는 파인튜닝한 모델을 사용할 예정이다.


근데 다들 OpenAPI써서 많이 한다. 본인이 직접 LLM을 만들어서 쓰는경우가 생각보다 .적네 당당하게 Gpt를 쓴다...신기.. 비용생각 크게 안하는구나..

**쉬는 시간**
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
## 4) 나는 왜 코프링 컨트롤러를 더 이상 만들지 않게 되었나?
**백엔드 개발자(대학생) 김경환**
코틀린 스터디 소개, Open API, ...
데보션 영 3기 발표자이다.
코틀린 프로그래밍 언어와 프레임워크 이용하여 간단한 MVP REST API 개발하기. 대학생 2명, 현직자 9명, 서포터즈 1명

**Spring + Kotlin + OpenAPI** 활용한 프로젝트를 진행하였음. 그 중 오늘 이야기는 OpenAPI에 관한이야기.

기존의 프로젝트 커뮤니케이션.
- 백엔드가 API 개발하고 파라미터 수정해서 배포함 / 프론트가 개발 서버에 붙여서 개발을 진행.. 근데 에러가 발생. / 테스트를 돌렸을땐 잘됐는데??? 원인을보니.. API 명세서 최신화가 안되어있었다.. 그러면 최신화 후 알려주기
- API 명세서는 언제 수정하지?? 쉽게 수정하는 방법 없나? => **Swagger를 도입**. 많은 백엔드 개발자들이 사용하고 있음. Swagger 어노테이션 삽입하여 코드와 함께 API 문서를 관리, 생성 가능함.

Swagger를 기반으로 나온것이 바로 OPENAPI 이다. HTTP API를 위한 표준 인터페이스 정의.
기존의 Swagger Specification이 정착한것에서 OpenAPI가 시작되었음.
- 표준화 된 포맷 (JSNO 또는 YAML)
- 특정 언어나 프레임워크에 종속되지 않음 (유연성)
- 코드 생성 - **OpenAPI Generator**. 표준에 맞게 명세서를 만들어준다.

**OpenAPI Generator란?**  
OpenAPI 규격에 맞게 API를 표준화하게되면, StubServer(더미서버)를 생성할 수 있고, Client SDK로 자동으로 생성해줌. API를.. 더 쉽게. 메소드 형태로 API를 호출할 수 있음.
예시응답 또한 더미 Response로 자동 생성해준다.
결과적으로 Spec 파일로 API명세서 작성하여 효율적으로 운용 가능

Spec파일이란,(Swagger Editor로 확인가능)
먼저 openapi 사양
info에 문서기본정보기술
Server에 API서버들의 URL과 설명을 나열
tags
paths는 각 경로에서의 HTTP메소드,요청,응답 정의
components는 엔드포인트에 구성요소를 정의

1) 먼저 OpenAPI Generator Install을 해야함
2) 그리고 설치 말고 일회성으로 코드 생성하고 싶다면 Editor.swagger.io에서 spec파일을 import하여 Generate Client 탭으로 생성가능. (다양한 언어나 프레임워크 지원)
3) 생성한 코드를 살펴보면 apis, models가 생성됨.
4) Factory 패턴을 기반으로 SDK가 생성됨. 따라서 메소드 호출로 간편하게 API 연동이 가능하다. (하나의 메소드로 axios를 만들어주는 느낌?)
5) **ServerSide Generation은** 어떻게 이루어지는가? Spec파일을 기반으로 프로젝트 빌드 시, Stub Server 코드가 생성됨. 코드 내부엔 Swagger관련 Annotation과 default 컨트롤러 interface 생성해주고, 예시응답 생성
6) 인터페이스로 이제 생성이 된 코드를 어떻게 사용? Override 후 비즈니스 로직을 삽입하면 된다.
7) **그래서 왜 코프링 컨트롤러가 필요하지 않는지...**
	1) Stub Server 코드 생성으로 직접적인 컨트롤러 개발이 필요없음
	2) 생성된 컨트롤러 부분의 코드를 Override 받아 작성
	3) 컨트롤러 부분을 Override하여 구성하기때매 비즈니스 로직에 집중가능
	4) Stub Server 코드 내에 Swagger UI가 적용되어 있기에 **실제 봐야하는 소스코드가 더러워지않음.**
	
**이로인해 어떻게 변화하였는지!**
백엔드 개발자는 Spec파일 업데이트했다고 말하면, Client는 Spec파일로 SDK생성해서 작업한다고 할 수 있음. 정상 동작! 

**실제 프로젝트 적용 후기**
1) 리팩토링 적용. 기존 개발된 플랫폼은 레거시 코드 자바 버전 업그레이드.. 도메인 별 각기 다른 디자인 패턴 적용. 이미 작성된 API 명세서가 존재했다. 이걸 OpenAPI Spec으로 수정하고, OpenAPI Generator로 활용했다.
2) 서비스 개발 중 특정 오픈소스와 연동하고자 하는 의견. REST API를 지원함을 확인. 오픈 소스 Repo구경 중 OpenAPI 규격의 Swagger Spec 파일이 있는것을 확인하여 이걸로 Client SDK 생성하여 개발을 진행하였음.

파이프라인..
- OpenSource Repository가 있음. Pulling하고있다가 Clone이 되면 SDK를 생성하여 Nexus에 Publish했고, 개발자는 SDK를 가져와 작업하면 깔끔??

**질의응답**
Q1.구체적으로. A. 데보션서버 소스가 어떤지 고민할 필요없이 Spec파일을 import하고 자바라이브러리로 뽑아내서 Maven에 넣어주었다. 그러면 메소드만 호출하고 파라미터만 넣으면 자동으로 됐다? 시간 절약에 좋았다.
Q2. 대학생이 스터디 모임에 참여할 때의 장단점 공유 / A. 대학생 2명과 현직자 9명이었는데.. 인사이트를 굉장히 많이 얻었다! 기술스펙은 단순히 썼겠지만, 왜 써야하는지 이유를 찾아가는것이 중요하다는 것을 깨달았다. 다양한 직군 사람이 모여있어서 진로 찾는데도 도움이 많이되었다. 단점은 이해하는 수준이 Gap이 있어서 따로 찾아봐야 했었다. 뒷공부가 필요.. 
Q3. 기존 레거시 코드에 Spec 파일 없이 Generate 하는 방법이 있는지? / A. 규격에 맞지않는것은 안된다. Spec파일 기반으로 작성해서 코드를 생성해준다.
Q4. RestDocs와 비교? / A. Restdocs랑 Swagger랑 비교대상이고, 오늘 발표는 OpenAPI Generator쪽이기에.. 따로 블로그로 작성해보겠다.
Q5. 클라이언트에서 여러개 API를 사용하면 Spec파일이 여러개 생성될것같은데 하나로 합칠수있는지? / A. 단점이 있다. 도메인별로 스펙파일을 분리하여 할수도 있고 하나의 스펙파일에 다 넣을수도 있긴한데, 여러개 생성한경우 Base가 있고 import하는 다른경우 있을텐데 Spec파일도 모듈화 개념이 있는것같다. 그래서 base에 링크만 걸어주면 자동으로 보게되어 하나의 SDK로 사용이 가능하긴하다.
## 5) SQL 쿼리 작성, 이제는 쉽고 빠르게 LENS
**KB 프론트엔드 개발자 : 우원**
프론트말고도 데이터에도 관심이 많아 공부를 병행하고 있음.
오픈랩 지원서에 성장에 대한 열정, 열망을 작성했는데 이러한 점을 좋게 봐주셔서 할 수 있게 됐다.

데이터 분석화를 위한 데이터 추출 자동화 및 EDA 추출? 
마케터, 엔지니어, 데이터분석가들이 사용할수있는 기능들을 추가해왔음
시작은 디자인 컨셉 잡기. (볼록렌즈, 오목렌즈처럼 빛의 굴절에서 착안하여 빛)

**LENS가 해결하고자 하는 문제?**
모든 직군에서 데이터를 공부하는 현황이다. 데이터분석쪽에 대한 수요가 뚜렷함을 알 수 있다.
관련 자격증 수요조차도 매년 크게크게 증가하고있다.
**세 가지 문제**
1) SQL에 의존한다. (익숙치않아)
2) GEN AI 활용시 실제 DB 스키마 정보가 반영되지 않아 사용자의 수정과 검토가 필요하다.
3) ...

우리 회사 DB에 최적화된 AI DB생성이 가능하면 좋지않을까? 하여 생성하게 됨.
막상 SQL을 작성하려하면 생각이 나지 않는 경우가 많음. 다들 구글링에 의존하곤함.
개발은 프론트 Next.js와 배포는 Vercel를 사용함.

채팅모드, SQL모드, 스키마 모드.
일상대화와 쿼리작성이 자연스럽게 됐어야했다. 그것이 목표였다.
테이블이나 쿼리 관련 질문은 어떻게 판별하는지? => LLM과 Function Calling으로 구현한다.
FunctionCalling은 사용할수있는 쿼리를 정리하여 ?

랭체인에서 가져오고 주석으로 어떤역할하는지, 값은 어떻게 나오는지 정확히 입력

Prompt Engineering + persona, constraints, few shot
하지만 완벽하지 않았고, RunnableWithMessageHistory. 메세지 객체를 보면 HumanMessage, AIMessage, ToolMessage를 지켜야했다. 상단에 사람의 메세지가 입력되고, AI메세지가 각각의 가격을 가져오고 함수를 불러오고..., ToolMessage는 
...?
가장 먼 과거, 과거, ... 과거, 가장 가까운 과거 이렇게 History를 10개로 가장 앞부터 10개를 사용하려했는데, Pair Rule이 지켜지지 않았다. 

항상 마지막은 AI메세지거나 Toolmessage로 끝남. Pair Rule이 적용되는것은 ToolMessage뿐이다. Toolmessage아닌메세지 만나면 그 즉시 자른다.
기본 10=>15, toolmessage 절사할때 대략 2~3.
그러니 Pair Rule에 위배되지 않는다.

차기LENS 방향은 대형스키마 고나리, 인덱스 최적화, DB성능개선전략 / 애널리틱스를 위한 기초통계, 사용자별과 부서별 통계, 비용 계산

**질의응답**
Q1. 컬럼명이 직관적이지 않은 경우도 대비가 되는지? 실무는 요약단어나 명칭을 많이 쓰는데.. / A. 컬럼명 직관적이지 않은 경우는 대비가 되어있지 않음. 각 컬럼 내용이 입력당시 수기로 되어있는 방식. 테이블 전체를 LLM에 넣은게아니고, 컬럼 정보를  Info로 뽑아서 낸것. 추후에는 입력하는 고객에게 세부적인 컬럼을 요청하고, 그걸통해 잘 찾을 수 있지 않을까 싶다.
Q2. 사용자가 대충 질문하고 퀄 좋은 답변을 원하는경우가 많은데 어떡한가. / A. LLM에 맡기면 되지않을까요. 사전질문을 잘 넣기만했으면..
Q3. 펑션콜링해보면 펑션 많아질수록 구분 모호성때문에 적절한 펑션이 선택되지 않는 경우가 있던데, / A. 내부에 Description을 잘 하면된다?
Q4. DB스키마 관련해서는 ERD만 입력하면 바로 테이블 생성으로 전환해주는지? 케이스(서비스) 별로 ERD를 설정하고 쿼리를 할 계획이 있는 것일까요? / A. 아직 그쪽이 되진않는다. 
Q5. 가장 좋았던부분, 힘들었던 부분? / A. 수원에 사는데 올때마다 기분이 좋다. SKT타워를 지나올수있어서 좋았다. 좋은 동료를 얻은것이 좋았다. 그런데 다른프로젝트 병행하다보니 시간분배가 어려웠다. 그것때문에 밤을 좀 많이 샜다..

## 6) Kubeflow 알아보기
**김예은**
여러가지 경험으로 성장하는 개발자.
쿠버네티스, 쿠베플로우

세가지목차.
Kubeflow란? Kubeflow 구성요소, MLOps

Kubeflow란? Kubernetes + ML Workflow 합친것.
개발자, 데이터사이언티스트, ML엔지니어 등 모두가 모델 구축부터 테스트 배포...

어떻게 사용하는것?
**Kubeflow는 ML에 특화된 Workflow**이다.
6개의 컴포넌트들..
Pipeline은 Kubeflow Pipeline
Notebooks는 Kubeflow Notebooks(쥬피터노트북, vscode로 사용가능)
Dashboard
AutoML
Model Training : KubeflowTraining Operator
Model Serving : KServe로 API로 쉽게

Kubeflow Notebooks는 웹 기반 개발환경 실행할 방법을 제공 유형 및 패키지는 Docker 이미지로 선택 가능
Kubeflow Pipeline은 KFP라고도함. SDK를 쓰고나 Yaml파일을 이용해 누구든 쉽게 pipeline구축가능. 시각화로 한번에 보기도좋음
또 yaml파일말고도 Clinet를 생성하여 바로 확인가능

Notebooks에서 코드를 작성하면 (Component를 작성 (함수를 컴포넌트로 정의)) 
컴포넌트 작성 후, pipeline을 생성한 뒤, 파이프라인함수를 정의한다. 그 안에 위에서 작성했던 컴포넌트 함수들을 활용함. step1.output을 다른 애들의 입력값으로 넣을수있음.
이제 yaml파일로 생성할수있다. 대시보드에서 CreatePipeline으로 이름 명시도 가능.

이제 잘 실행되어 생성되었다면, UI적으로 어떻게 값이 연결되어 들어가고있고... 그 통과당시 값은 몇이고.. 등 확인할 수 있음

**Training Operator**
ML모델의 미세조정(파인튜닝) 및 분산학습을 위한 Kubernetes 기반 프로젝트임
**Katib**
AutoML을 위한 Kubernetes 기반 프로젝트
하이버파라미터 튜닝, Early Stopping, Neural Architecture Search(NAS)를 지원
Api로도 사용이 가능하게 됨. Best Trial's params를 알 수 있게 된다. (learning rate와 epoc을 원해서 알 수 있었음) loss랑 accuracy를 확인할수도 있다.

이제 모델을 Serving하기 위한 KServe를 사용할 수 있다. 서버리스 배포를 제공한다. 자동확장도 되고, 네트워크 살아있는지 확인여부도 가능함. 만들어진 모델을 가져와 사용하기에 지원하는 Storage는 전체적인 형태를 지원하고있다. 쉽게 배포가 가능함

모델 목록, 모델 상태, 예측, 예측설명도 get이나 post 요청으로 할 수 있음.

**이렇게 전체적인 Kubeflow를 살펴봤는데, 그러면 왜 이런 Kubeflow가 ML에 특화됨?**
Kubeflow는 pipeline으로 관리하여 pipelines, katib, Kserve 간단히 올리고 post요청으로 가져오는것까지 했었음. 

**질의응답**
Q1. 기존 쿠버네티스 클러스터 운영 경험 있나요? / A.없다. 이번에 스터디 경험으로 쿠버네티스 0부터 잘하는사람부터 전체적으로 해보자 하여 참여하게된것이다.
Q2. 실제로 Kubeflow로 학습한 모델이 있나요? 만약 있다면 사용하면서 불편한점은? / A. 간단하게 iris데이터셋 학습같은것을 진행했는데, 제일 불편했던걸 뽑자니 기존 컴퓨터로 하기에 용량이... 비용이... 그런것말고는 불편한점이 없었다. 쿠버플로우가 파이썬으로 사용할수있었어서...
Q3. MLflow와 비교하여 장단점은? / A. 쿠베플로우가 좋은점은 쿠버네티스와 연결되어있고 배포까지 쉬움. 

쿠버네티스 방향으로 많이 가고 노력하는 상황이다.. 공부해두면 좋을라나?

**쉬는시간**
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

## 7) 대규모 시스템 첫걸음
**최윤식**
- 대규모 시스템에 관심있는 주니어 개발자를 위한 발표
1) Server
2) Database
3) Key-value Store
4) Consistent Hashing
5) GUID

대규모시스템 설계가 중요해지고있다. 많은 사용자로 인해 많은 Traffic이 발생하고, 그로인해 많은 데이터가 발생한다.
- 대규모시스템 하기위해 우선 **성능**이 필요하다.
- 장애상황을 필히 마주치는데, 서비스 중단 없이 서비스에 대응할 수 있는 고가용성이 있어야함
- 확장성을 고려해 설계해야함

서버 1대부터 시작하여 점차 확장하는 서버를 설계하는 여정을 떠나보자.
간단한 방법으로는 Scale Up / Scale Out이 있다. 서버 성능을 늘리거나, 서버를 추가하거나

- Traffic이 적을때는 더 간단한 Scale Up을 할 수 있다. 대신 한 대의 서버가 장애가 나면 서비스가 마비될 수있다. SPOF를 생각해야함 (하나 메인이 장애가 생기면 전체가 작동하지않는 문제)
- ScaleOut의 경우를 살펴보자. 서버를 더 추가하는 방식. 장애가 발생해도 다른 서버가 대체하여 돌아가기에 고가용성이라는 장점이 있다.
- **Scale Out을 선택하지만**... scale out의 단점은 더욱 복잡하다. ScaleUp은 세션, 토큰, 유저데이터 등 다양한 정보를 그냥 다 가지고있으면된다. 근데 scale out은 여러 서버에서 이런 상태를 가지고있지않아 에러가 날 수 있다. 그래서 서버를 Stateless 서버로 만들어야 한다. (필요할 때 가져와 사용하는 방법. 무상태)
**DB**
- Database도 하나면 SPOF가 발생한다. DB를 두대 두고 복제해두고 장애가 발생할때 다른 DB로 옮겨가 사용하는 방법을 사용할 수 있다.

**근데 만약 서비스가 더욱 확장되어간다면??**
- 기존 구조로는 어려움. 어떻게 해야 성능을 향상시킬수있을까?
- DB 두개에서 한대는 CUD, 다른한대를 R만해서 (CRUD중에) 해결했다. 
**근데 더더욱 성장한다면?**
- Read는 위에서 개선했는데 CUD작업은 개선되지 못했다 아직.
- 복제된 DB에서 Read를 한다는건 좋다. 근데 결국 CUD는 한곳에서 하는데, 그로인해 CUD되지않아 Read안되는 문제가 생길수있다. 그래서 순서를 사이사이 껴서 진행? (샤딩?)

**Key-value Store**
- 메모리 계층구조에 따른 속도.. Redis가 메모리를 사용하여 DB보다 빠르다. 무려 postgre보다 100만배? 그래서 cache layer를 도입하도록함..
- 근데 또 cache서버가 하나라면 SPOF가 발생할 수 있다. 그래서 캐시도 여러대여야한다.
- 분산된 캐시면 결국 문제가 생긴다. CAP정리 (Consistency, Availability, Partition Tolerance 모두만족하는건 불가능하다) Consistency는 언제나 같은 데이터를 바라봐야함. Availability는 언제든 반응할수있어야함. Partition tolerance는 두 노드 사이에 통신장애가 발생해도 시스템은 계속 동작해야함
- 따라서 3개중 2개를 만족하는 DB들 종류가 있다. CP를 만족하는 redis, CA를 만족하는 DBMS, AP를 만족하는 어쩌구..
- 여러개의 Cache server에 key값을 쓴다. 모든 서버에 데이터를 쓰게되면 좋을것같지만 성능이 저하된다. (trade off)
- 그래서 Quorum Consensus를 사용하여 읽기 쓰기를 보장. 쿼럼이란 여러사람이 합의로 운영되는 의결되는... 최소인원
- W는 쓰기연산에 대한 Quorum, R는 읽기 연산에 대한 Quoreum이다. N은 개수
Partition tolerance
네트워크 장애... 언제든 발생할 수 있다. s0과 s1이 정상인데 네트워크가 끊길수도있다. s0이 s1을 장애서버로 생각하게 할 수도 있다. 모든노드를 다 연결하는것은 매우 비효율적이다.
Gossip Protocol로 이를 해결할 수 있다. 멤버십 목록에 대한 Heartbeat counter를 가지고있고, 주기적으로 본인의 Heartbeat를 증가시킨다. 무작위 노드를 선정하고, 선정된 노드들에게 정보를 전달하게됨. 갱신도함.
- 근데 갱신이 안된다? 장애로 감지함. System을 장애상태로 가만둘수없기에 조치해야함.
- Quorum Consensus를 사용하여 해결가능. 만약 한대의 서버가 장애 발생하면 일관성 보장을 위해 다른 캐시에 작성을 막아야함.
- 만약 한대 서버가 마비되면 다른노드가 임시로 이관되어야함

**Constitent Hashing**
cache가 성능은 좋은데 DB에 비해 성능이 좀.. 현재세대 최대가 635mb이다. 그래서 하나의 캐시에 모두 저장하는게 아닌, 나눠서 저장해야한다. 근데 이러면 하나의 캐시에 몰려 과부하?

나눠야한다. 어떻게? Hashing을 사용한다. 특정키에대해 Modulo 연산을 하면된다. 근데 서버추가나 삭제의 경우 대규모 rebalancing이 필요하다. 따라서 Consistent Hashing이 필요하다.

x0부터 xn까지의 범위가 있다고 생각해보자. Ring에 이들이 연결되어있다면.. 시계방향 돌다가 가장 가까운 서버에 저장. key별로 서버별로... 
서버제거 또한 대규모리밸런싱없이 나머지 키에 큰 영향을 미치지않음.
키를 나누어저장하면 같은 키가 여러 캐시에 저장되는경우..? 키가 중복되지않도록 캐시 저장할 기능을 찾아봐야함.

키의 유일성을 활용하기 위해 . UUID v4. 128비트의 수로 로또보다 되기가 어렵다.
규모확장도 쉽다. 근데 엄청 길고... 생성된 정보를 시간순으로 /.........../;;;;;;;

GUID는 티켓서버가 또 SPOF가 발생할 수 있다. 모든 시스템이 영향을 받게 된다. 이런 문제 해결을 위해 GUID로 유의 식별자를 활용.
GUID를 사용해도 중복은 발생할수있음. 

대규모 시스템을 사용하기 위해선 지속적으로 시스템을 가다듬고 전략을 세워야한다.
마지막으로, facebook, amazon, google, ..
**대규모 시스템 설계 기초 라는 책**으로 공부했다.

**질의응답**
Q1. 책으로 어떻게 스터디? / A. 2주간 책 보고 발표하는 전형적인 스터디 형식으로 하였음

## 8) C++ 개발자가 바라보는 Rust
**SK텔레콤 양유석**
SK텔레콤에서 AI쪽 하고있고, C++커뮤니티쪽 하고있고
책 : The Rust Programming Language 2nd

Rust와 C++를 비교한것은 인터넷에 많이 있음. C++개발자로서 Rust보단 C++의 중심에서 내용이 전개될 예정. Rust를 빙자한 C++이야기

C++이라는 언어는 1983년에 이름이 바뀌었고. Bjarne라는분이 만듦
First Version of C++이 1983 / 업데이트가 되어왔고.. 2010년 안에 하겠다했는데 2011년에 대규모업데이트가 이루어짐. 2011년도 C++11
2011년 전과후로 C++을 이야기하는데 C++은 3년주기로 꾸준히 업데이트 되고있다. 계속 대규모업데이트

학교에서도 많이 안배운다는데 그나마 배우는 C++을 보면 C++11 이전의 내용을 다룬다. 안타깝다.

**Rust란?**
모질라 제단에서 일하다가 Graydon Hoare라는분이 취미로 시작.
안정성에 중시하며 Rust를 만듦. 좌절감에 빠진 C++개발자가 주 타겟층
- 2024 현재. 가장 칭찬받는 언어가 Rust 84.66%로 1위였다. C++은 44.11%이다. 계속 이래왔던 상황이다.
TIOBE 순위를 보면, 2024년 8월 기준 / 인기많은건 1위 Python, 2위 C++이다. 근데 Rust는 14위이다.
그래도 선전해서 올라가고있다. 

**왜 Rust는 C/C++과 비교대상이 되는가? 왜 더 좋다고하는가?**
- MS Azure CTO의 발언. Rust는 C++을 대체할수있냐는말에 신규 프로젝트는 C나 C++이아니라 Rust를 써야한다. 라고 말한것이 큰 논란.
- 백악관도 안전하게 Go, Rust, Java를 쓰고 C나 C++을 쓰지말라고 하고 그럼..
- 심지어 Swift가 C++을 대체할수있는 최고의 언어가 이런식으로 C++을 동네북처럼하고있음..
**과연 진짜 안전하지 않은 언어인가?**
=> 그렇지는 않다. 충분히 안전한 표준라이브러리들이 있다. 심지어 정적분석도구도 많다.
표준이 그리고 계속 업데이트 되고있다. 멈춰있지 않다. 그러니 쓰는사람이 문제인거지 언어 자체의 문제는 아님. 굳이 문제라하면 그 실수를 방치한거? 

Rust는 컴파일에서 에러가 발생한다. 의도한 경우엔 unsafe{}라는 것을 처리해야한다.
대체 비교를 많이하던데 어떤 특징이 있는지?

**Rust특징**
- 메모리 안정성 (다른언어도 있긴함)
	- 소유권 시스템
	- 빌림과 수명 (borrowing and lifetimes 이건 rust쪽만 있는것같기도함) - 어디까지 쓰고 어디에서 해제해야하는지 알려줘야함
- 안전한 동시성(Safe Concurrency)
- 철저한 컴파일 타임 검사 - 단, 오래걸린다 그래서...
- 강력한 패키지 관리자(Cargo) - C++은 이런게 없긴하다. 
- 제로 비용 추상화
- 완전한 포인터(Safe Pointers)
- 매크로 시스템

**Rust와 C++의 닮은점**
- 배우기 어렵다. => 왜? CS지식이 많이 필요하다. 메모리 관련 이해를 하려면 어쩔수없다. 
- OS를 만들 수 있는 언어 => 메모리에 직접 접근이 가능함
- 컴파일 언어 => 높은 성능
- 멀티패러다임 언어
- 메모리 관리에 대한 제어

**OS를 만들수있는 언어라는 말..?**
정확히는 OS 커널을 만들수있다. Assembly, C, C++, Rust 이런애들이 OS를 만들수있다.
하드웨어 제어를 위해선 메모리에 직접 접근이 가능해야함. 그니까 메모리 ㅇ