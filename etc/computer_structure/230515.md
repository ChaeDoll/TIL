# 컴퓨터구조 복습  
## 강의자료 02  
중간고사 범위까진 공부 다 함... Loop의 원리, 프로시저 이동 원리 등등  

동기화와 관련된 MIPS의 명령어  
동기화할 레지스터 rt값을 메모리에 저장하고, ll명령어를 사용한다. (load linked)  
ll을 통해 rs주소에 있는 값을 가져오고, sc 명령어(store conditional)를 통해 rs에서 가져온 rt값과 rs값이 같은지 다른지 (메모리 값이 바뀌지 않았는지)를 통해 동기화가 성공했는지 아닌지 알 수 있다.  
sc를 거쳐서 rt에 1이 저장되었다면 메모리 값이 바뀌지 않았다는 것이고, rt가 0이 저장되었다면 메모리값이 바뀌었다는 것을 의미한다.  
? 뭔 개소리야  

컴파일러는 c프로그램을 어셈블리 언어로 바꿔줌.  
컴퓨터가 이해가능한 명령의 기호형태  
상위수준언어는 생산성 향상.. 문장수가 더 적기에!  
옛날엔 컴파일러가 비효율적이라 OS와 어셈블러는 어셈블리어로 작성함  
지금은 좋은 컴파일러가 많다.  

어셈블러는 기계어프로그램으로 번역  
의사명령어라는 것도 있는데, 원래 없는 명령어를 어셈블러가 제공할수도있음.  
이로인해 컴파일이나 어셈블리언어 프로그래밍을 용이하게 할 수 있음.  

어셈블러 의사 명령어는 더 풍부한 명령어 세트 제공을 위한 확장.  
move $t0 $t1은 add $t0, $zero, $t1 으로 구현가능  
blt $t0, $t1, L은 slt $at, $t0, $t1과 bne $at, $zero, $L로 구현됨 ($at는 어셈블러 전용 임시변수레지스터)  

정렬 프로시저... 보고 이해중  

## 강의자료 03  
컴퓨터 연산. 우리가 일반적으로 덧셈하듯 더하고 올림수는 오른쪽에서 왼쪽으로 이동시켜준다.  

뺄셈 : +7과-6을 더하는 구조 0000 .... 0111 + 1111 .... 1010을 더한다.  
1 0000 .... 0001 이라는 값이 나오는데, 맨 왼쪽 올림수로 인해 발생한 1은 무시한다. (비트밖)  

<b>연산에 있어서 오버플로</b>  
다른 부호끼리는 덧셈할때는 오버플로가 발생할 일이 없다.  
하지만 같은 부호에서는 오버플로가 발생할 수 있다.  
오버플로는 표현할 수 있는 수를 넘어갈때 발생하는 문제  
뺄셈의 경우엔 다른부호끼리 발생할 수 있다. 같은 부호에서의 뺼셈은 마찬가지로 오버플로 발생안함  
몇몇 언어들은 Overflow를 무시한다.  
MIPS에서도 addu, addui, subu 명령어를 사용하면 오버플로를 무시한다. 또한 예외처리도 발생하지 않는다.  
하지만 Ada, Fortran의 경우에는 예외처리가 발생된다. MIPS의 add, addi, sub명령어를 쓰기 때문. 오버플로 발생시 처리하기 위한 프로시저가 호출된다.  
MIPS는 이처럼 예외처리를 시키는 명령어도 존재한다. but, 검사를 위한 명령어는 제공하지 않는다.  

<b>곱셈</b>  
곱셈 알고리즘은 크게 세가지,  
기본 알고리즘(오래걸림), 개선 알고리즘, 다중덧셈기 이렇게 볼 수 있다.  
- 기본 알고리즘  
피승수와 승수를 사용하여 곱을 구한다. 피승수:곱해지는 대상, 승수:곱하는 수  
1000x1001 의 경우를 예로 들어본다. 먼저 곱을 0으로 시작했을 때, 승수의 LSB(가장 우측 비트)가 1이냐 0이냐를 확인한다. 만약 1이라면 현재 승수를 곱(Product)에 더하고, 0이면 더하지않고 진행한다.  
한 사이클이 돌때마다 피승수의 레지스터를 1비트 왼쪽으로 이동하고, 승수의 레지스터를 1비트 오른쪽으로 이동한다.  
위의 경우에선 자리수 이동으로 인해 10000x100이 된다.  
다시 승수의 LSB를 확인하며 피승수값을 차례차례 곱에 더해준다.  
기본 알고리즘에서는 피승수와 ALU와 곱은 64비트이고, 승수는 32비트이다.  
기본적으로 피승수와 승수를 32비트 수로 받고, 승수가 32비트만큼 오른쪽으로 이동하며 더했을때 피승수도 32비트 왼쪽으로 이동하기위해 64비트로 두는 것이다.  
이렇게 계산을 마친 뒤 Product가 64비트인것은 자연스러운 일.  

ALU는 프로세서의 연산을 담당하는 장치이다.  
+,-,*,/ 을 연산할 수 있고,  
AND, OR, XOR, NOT.. 등 논리연산을 수행할수도 있다.  
Shift Register를 할 수도 있고  
보수기를 사용하여 데이터의 음수화를 가능하게 해준다. (2의 보수)  

- 개선된 하드웨어  
위에서는 64비트의 피승수, ALU가 필요했다.  
개선된 하드웨어에서는 add와 shift를 병렬적으로 수행하기에 더욱 빠르게 계산이 가능하고, 심지어 승수에 관한 것도 Product(곱)에 저장한뒤 연산을 시작하기에 승수에 관한 하드웨어도 아낄 수 있다.  
Product 우측 하위 32비트에 먼저 승수가 저장되어 있는 상태로 시작한다. 승수의 LSB값을 확인하여 1인지 0인지 보고, 1이라면 피승수를 Product의 왼쪽 32비트에 저장한다. 더해지면 Product를 shift right한번 해주면 승수는 다음 LSB가 나타나고, 피승수는 값을 더하기 이전에 자릿수를 올려준 효과를 나타낸다.  
이후 다시 승수의 LSB를 통해 1이면 피승수를 곱의 상위 32비트에 더하고, 이를 32번 반복하면 기존에 승수가 있던 자리에 곱의 1의자리부터 저장이 되어있을 것이고, 승수는 사라져있을 것이다.  
기본 알고리즘보다 하드웨어 비트수를 절약할 수 있고, 승수 하드웨어를 필요로하지 않고, 승수와 피승수의 자리이동이 동시에 일어난다는 점에서 잘 개선되었다고 볼 수 있다.  

- 다중 덧셈기  
병렬 트리 구조로 만들어진 다중 덧셈기는, 덧셈기를 많이 사용하긴 하지만 빠르게 곱셈을 구할 수 있는 방법이다.  
