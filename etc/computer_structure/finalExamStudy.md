# 컴퓨터구조 기말고사 공부
## Chapter 03
컴퓨터에서 정수의 연산(덧셈, 뺄셈, 곱셈, 나눗셈, 오버플로 다루기)과 부동소수점(표현 방법과 연산 방법)에 대해 알아본다.  

- 컴퓨터 수 표현 방법, 산수연산 알고리즘  
- 알고리즘을 위한 하드웨어 설계
- 명령어 집합에 미치는 영향  

### 정수 연산
- 덧셈 : 오른쪽에서 왼쪽으로 계산한다. 오른쪽에서 왼쪽으로 넘어가는 올림수(carries)가 발생할 수 있다.
- 뺄셈 : 7-6의 형태를 7+(-6)으로 생각하여 계산할 수 있다. 다시 말하면, 뺄셈을 할 수를 **2의 보수화** 처리한 후 덧셈 과정처럼 계산할 수 있다.  
혹은 뺄셈을 당하는 수의 MSB가 2(빌림수)가 있다는 가정을 통해 뺄셈을 할 수도 있다.  
이 과정에서 발생하는 범위밖(MSB) Carry(올림)이나 Borrow(빌림)값은 무시한다.  
- Overflow : 메모리의 허용범위를 초과하여 값이 들어오는 경우 발생  
스택 영역이 힙 영역을 침범하거나 힙 영역이 스택 영역을 침범하는 경우  
연산에서 발생하는 오버플로우는 연산 후의 결과가 하드웨어(32비트 워트)에서 표현할 수 없는 경우에 발생한다.  
MSB(부호비트)를 값 비트들이 침범해서 이상한 값으로 바뀌는 경우다.  
**다른 부호끼리의 덧셈 / 같은 부호끼리의 뺄셈은 오버플로우 발생 X** - 절댓값이 작아지는 경우이기에 오버플로우가 발생하지 않는다.  
반면 **같은 부호끼리의 덧셈 / 다른 부호끼리의 뺄셈** - 오버플로우가 발생할 수 있다. 절댓값이 증가하는 연산이기 때문이다.  

> Overflow가 발생했는지 탐지하는 방법 - MSB(부호비트)를 크기비트가 침범하여 값이 바뀌어버린다. 부호비트로 올림수가 올라가기 때문. 따라서 부호비트의 변경여부로 Overflow를 확인한다.

C,Java같은 몇몇 언어는 오버플로를 무시하여 예외처리를하지 않지만 (MIPS addu, addui, subu 명령어를 사용함)  
다른 언어들은 예외처리를 발생시킨다 (MIPS add, addi, sub 명령어 사용) 하지만 예외처리를 발생시키는 언어들 조차 예외처리는 시키지만 검사를 위한 명령어는 제공하지 않는다.  

### ALU (산술논리연산장치)
프로세서에서 연산을 담당하는 장치이다. ALU의 구성은 크게 4가지이다.  
1. 산술연산장치 : +, -, *, /과 같은 산술연산을 수행한다.
2. 논리연산장치 : AND, OR, XOR, NOT 등 논리연산을 수행한다.
3. 시프트레지스터(shift register) : 비트들을 좌,우로 이동시키는 기능을 가진 레지스터가 있다.
4. 보수기(complementer) : 데이터를 2의 보수화 한다. (음수화)

### 곱셈 연산  
- 기본 알고리즘 : 64비트의 Multiplicand(피승수), 32비트의 Multiplier(승수), 64비트의 ALU(연산장치), 64비트의 곱(Product) 를 가지고 연산을 한다.  
    1. 이진수를 기준으로승수의 LSB(가장 오른쪽 비트)를 보고 1이면 피승수를 곱에 더하고, 0이면 더하지 않는다. 
    2. 피승수를 왼쪽으로 1비트 쉬프트(shift left)하고 승수는 오른쪽으로 1비트 쉬프트(shift right)하여 단위를 위로 올려준다.  
    3. 승수의 비트 수만큼 반복 수행한다. 위 경우엔 승수가 32비트기에 32번 반복했는지 확인하고 32번 수행한 뒤에 종료하여 Product(곱)의 값을 확인한다.  
- 개선된 하드웨어 : add와 shift를 병렬적으로 수행하는 알고리즘으로 설계되어있다. 32비트의 Multiplicand, ALU로 위보다 절반 크기로 줄었고, Multiplier를 Product(곱)에 쓴 상태로 초기화하기에 별도로 필요로 하지 않는다. 64비트의 Product(곱)을 가지고 연산을 한다.    
    1. Product(곱) 하위 32비트에 Multiplier(승수)값을 초기화한다.
    2. Product의 LSB를 확인하여(Multiplier 값) 1이면 Multiplicand(피승수)를 Product 상위 32비트에 더한다.
    3. 위에서 피승수를 더하면서 저장함과 동시에 Product(곱)을 shift right해준다. 이 과정에서 승수의 단위와 피승수의 단위가 바뀌는 것과 다름없다. 올림수를 저장해야하기에 사실은  Product는 65비트이긴 하다.  
    4. 이 과정을 32번 (Product 하위 32비트 수 만큼) 반복 수행한다. 결론적으로는 Product(곱)에 있던 Multiplier(승수)는 전부 shift right되어 사라져있을것이고, Product에 더해지는 Multiplicand(피승수)는 단위가 올라가며 차근차근 더해지고, 32번 반복수행된 결과 곱의 결과가 Product에 저장되어있을것이다.  
- 더 빠른 곱셈 : 다중덧셈기를 사용하여 병렬 트리 구조로 연산을 수행한다. 덧셈기가 늘어날수록 성능은 좋지만 코스트가 영 좋지 않을것이다. 이런 TradeOff를 고려하여 디자인해야한다. 트리 구조이기에 32번의 덧셈도 log2(32)=5번의 덧셈 시간이 걸린다.

**MIPS에서의 명령어**  
MIPS에선 두개의 32비트 레지스터를 사용한다. 따라서 곱셈명령어의 결과는 이 두 레지스터에 저장이 된다. HI:most-significant 32bits(큰값들), LO:least-significant 32bits(작은값들)  
곱셈을 사용하는 명령어는 *mult rs, rt / multu rs, rt*와 같은 명령어로 rs와 rt의 값을 곱하고 그 결과는 상위 32비트(HI)와 하위 32비트(LO)에 저장된다.  
곱셈의 결과는 *mfhi rd / mflo rd* 를 사용하여 레지스터 rd로 HI와 LO에 있는 값들을 이동시킬 수 있다.  
*mul rd, rs, rt* 를 사용하여 곱셈할 수도 있지만, 결과가 32비트를 초과해버리는 경우에는 적절하지 않다. (승수와 피승수가 너무 큰 경우)  

### 나눗셈 연산  
- 기본 알고리즘 : 64비트의 Divisor(제수)레지스터는 상위 32비트에 Divisor를 넣고 시작한다. 64비트의 Remainder(나머지)엔 피제수값이 초기화 된다. 32비트의 Quotient(몫)레지스터는 0으로 초기화 시킨다.  
    1. 초기 Remainder(나머지)에 저장되어 있는 피제수에서 Divisor(제수)값을 빼준다. 그 값이 0이상인 경우와 0미만인 경우로 나뉜다.  
    2. 뺀 결과가 0이상이라면 나눌 수 있다는 것이므로, 몫을 1비트 shift left 후 LSB에 1을 저장해준다. 만약 0미만이면 나눌 수 없다는 것이니, 빼기 전 값으로 복원하고 몫 레지스터를 1비트 shift left 후 LSB에 0을 저장해준다.
    3. Divisor(제수)를 1비트 shift right하여 다음 계산을 위해 피제수에 맞추어 제수를 정렬한다.  
    4. 위 과정들을 총 33번 반복한다. 32비트의 제수를 가질 때 n+1번이니, 반복횟수는 33번인 것이다.  
- 개선된 하드웨어 : 곱셈 개선 하드웨어와 같은 하드웨어를 사용한다. 32비트로 감소한 Divisor(제수)레지스터,ALU와 64비트의 Remainder(나머지)레지스터를 사용한다. 제수가 오른쪽으로 shift할 필요가 없고 피제수 레지스터와 몫 레지스터가 모두 Remainder에 저장되기에 필요없다.   
    1. 초기에 제수는 Divisor에 저장되고, Remainder 하위 32비트에 피제수가 저장된다.  
    2. Remainder의 상위 32비트(사실 33비트)에서 Divisor(제수)를 빼고 그 결과를상위 32비트에 넣는다. 결과가 0이상(양수)이면 Remainder(나머지)를 shift left하고 LSB를 1로 둔다. 결과가 0미만(음수)면 다시 원래값으로 복원하고 shfit left한 뒤 LSB를 0으로 넣는다.  
    



## Chapter 04
## Chapter 05