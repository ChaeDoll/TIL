# 컴퓨터구조 기말고사 공부
## Chapter 03
컴퓨터에서 정수의 연산(덧셈, 뺄셈, 곱셈, 나눗셈, 오버플로 다루기)과 부동소수점(표현 방법과 연산 방법)에 대해 알아본다.  

- 컴퓨터 수 표현 방법, 산수연산 알고리즘  
- 알고리즘을 위한 하드웨어 설계
- 명령어 집합에 미치는 영향  

### 정수 연산
- 덧셈 : 오른쪽에서 왼쪽으로 계산한다. 오른쪽에서 왼쪽으로 넘어가는 올림수(carries)가 발생할 수 있다.
- 뺄셈 : 7-6의 형태를 7+(-6)으로 생각하여 계산할 수 있다. 다시 말하면, 뺄셈을 할 수를 **2의 보수화** 처리한 후 덧셈 과정처럼 계산할 수 있다.  
혹은 뺄셈을 당하는 수의 MSB가 2(빌림수)가 있다는 가정을 통해 뺄셈을 할 수도 있다.  
이 과정에서 발생하는 범위밖(MSB) Carry(올림)이나 Borrow(빌림)값은 무시한다.  
- Overflow : 메모리의 허용범위를 초과하여 값이 들어오는 경우 발생  
스택 영역이 힙 영역을 침범하거나 힙 영역이 스택 영역을 침범하는 경우  
연산에서 발생하는 오버플로우는 연산 후의 결과가 하드웨어(32비트 워트)에서 표현할 수 없는 경우에 발생한다.  
MSB(부호비트)를 값 비트들이 침범해서 이상한 값으로 바뀌는 경우다.  
**다른 부호끼리의 덧셈 / 같은 부호끼리의 뺄셈은 오버플로우 발생 X** - 절댓값이 작아지는 경우이기에 오버플로우가 발생하지 않는다.  
반면 **같은 부호끼리의 덧셈 / 다른 부호끼리의 뺄셈** - 오버플로우가 발생할 수 있다. 절댓값이 증가하는 연산이기 때문이다.  

> Overflow가 발생했는지 탐지하는 방법 - MSB(부호비트)를 크기비트가 침범하여 값이 바뀌어버린다. 부호비트로 올림수가 올라가기 때문. 따라서 부호비트의 변경여부로 Overflow를 확인한다.

C,Java같은 몇몇 언어는 오버플로를 무시하여 예외처리를하지 않지만 (MIPS addu, addui, subu 명령어를 사용함)  
다른 언어들은 예외처리를 발생시킨다 (MIPS add, addi, sub 명령어 사용) 하지만 예외처리를 발생시키는 언어들 조차 예외처리는 시키지만 검사를 위한 명령어는 제공하지 않는다.  

### ALU (산술논리연산장치)
프로세서에서 연산을 담당하는 장치이다. ALU의 구성은 크게 4가지이다.  
1. 산술연산장치 : +, -, *, /과 같은 산술연산을 수행한다.
2. 논리연산장치 : AND, OR, XOR, NOT 등 논리연산을 수행한다.
3. 시프트레지스터(shift register) : 비트들을 좌,우로 이동시키는 기능을 가진 레지스터가 있다.
4. 보수기(complementer) : 데이터를 2의 보수화 한다. (음수화)

### 곱셈 연산  
- 기본 알고리즘 : 64비트의 Multiplicand(피승수), 32비트의 Multiplier(승수), 64비트의 ALU(연산장치), 64비트의 곱(Product) 를 가지고 연산을 한다.  
    1. 이진수를 기준으로승수의 LSB(가장 오른쪽 비트)를 보고 1이면 피승수를 곱에 더하고, 0이면 더하지 않는다. 
    2. 피승수를 왼쪽으로 1비트 쉬프트(shift left)하고 승수는 오른쪽으로 1비트 쉬프트(shift right)하여 단위를 위로 올려준다.  
    3. 승수의 비트 수만큼 반복 수행한다. 위 경우엔 승수가 32비트기에 32번 반복했는지 확인하고 32번 수행한 뒤에 종료하여 Product(곱)의 값을 확인한다.  
- 개선된 하드웨어 : add와 shift를 병렬적으로 수행하는 알고리즘으로 설계되어있다. 32비트의 Multiplicand, ALU로 위보다 절반 크기로 줄었고, Multiplier를 Product(곱)에 쓴 상태로 초기화하기에 별도로 필요로 하지 않는다. 64비트의 Product(곱)을 가지고 연산을 한다.    
    1. Product(곱) 하위 32비트에 Multiplier(승수)값을 초기화한다.
    2. Product의 LSB를 확인하여(Multiplier 값) 1이면 Multiplicand(피승수)를 Product 상위 32비트에 더한다.
    3. 위에서 피승수를 더하면서 저장함과 동시에 Product(곱)을 shift right해준다. 이 과정에서 승수의 단위와 피승수의 단위가 바뀌는 것과 다름없다. 올림수를 저장해야하기에 사실은  Product는 65비트이긴 하다.  
    4. 이 과정을 32번 (Product 하위 32비트 수 만큼) 반복 수행한다. 결론적으로는 Product(곱)에 있던 Multiplier(승수)는 전부 shift right되어 사라져있을것이고, Product에 더해지는 Multiplicand(피승수)는 단위가 올라가며 차근차근 더해지고, 32번 반복수행된 결과 곱의 결과가 Product에 저장되어있을것이다.  
- 더 빠른 곱셈 : 다중덧셈기를 사용하여 병렬 트리 구조로 연산을 수행한다. 덧셈기가 늘어날수록 성능은 좋지만 코스트가 영 좋지 않을것이다. 이런 TradeOff를 고려하여 디자인해야한다. 트리 구조이기에 32번의 덧셈도 log2(32)=5번의 덧셈 시간이 걸린다.

**MIPS에서의 명령어**  
MIPS에선 두개의 32비트 레지스터를 사용한다. 따라서 곱셈명령어의 결과는 이 두 레지스터에 저장이 된다. HI:most-significant 32bits(큰값들), LO:least-significant 32bits(작은값들)  
곱셈을 사용하는 명령어는 *mult rs, rt / multu rs, rt*와 같은 명령어로 rs와 rt의 값을 곱하고 그 결과는 상위 32비트(HI)와 하위 32비트(LO)에 저장된다.  
곱셈의 결과는 *mfhi rd / mflo rd* 를 사용하여 레지스터 rd로 HI와 LO에 있는 값들을 이동시킬 수 있다.  
*mul rd, rs, rt* 를 사용하여 곱셈할 수도 있지만, 결과가 32비트를 초과해버리는 경우에는 적절하지 않다. (승수와 피승수가 너무 큰 경우)  

### 나눗셈 연산  
- 기본 알고리즘 : 64비트의 Divisor(제수)레지스터는 상위 32비트에 Divisor를 넣고 시작한다. 64비트의 Remainder(나머지)엔 피제수값이 초기화 된다. 32비트의 Quotient(몫)레지스터는 0으로 초기화 시킨다.  
    1. 초기 Remainder(나머지)에 저장되어 있는 피제수에서 Divisor(제수)값을 빼준다. 그 값이 0이상인 경우와 0미만인 경우로 나뉜다.  
    2. 뺀 결과가 0이상이라면 나눌 수 있다는 것이므로, 몫을 1비트 shift left 후 LSB에 1을 저장해준다. 만약 0미만이면 나눌 수 없다는 것이니, 빼기 전 값으로 복원하고 몫 레지스터를 1비트 shift left 후 LSB에 0을 저장해준다.
    3. Divisor(제수)를 1비트 shift right하여 다음 계산을 위해 피제수에 맞추어 제수를 정렬한다.  
    4. 위 과정들을 총 33번 반복한다. 32비트의 제수를 가질 때 n+1번이니, 반복횟수는 33번인 것이다.  
- 개선된 하드웨어 : 곱셈 개선 하드웨어와 같은 하드웨어를 사용한다. 32비트로 감소한 Divisor(제수)레지스터,ALU와 64비트의 Remainder(나머지)레지스터를 사용한다. 제수가 오른쪽으로 shift할 필요가 없고 피제수 레지스터와 몫 레지스터가 모두 Remainder에 저장되기에 필요없다.   
    1. 초기에 제수는 Divisor에 저장되고, Remainder 하위 32비트에 피제수가 저장된다.  
    2. Remainder의 상위 32비트(사실 33비트)에서 Divisor(제수)를 빼고 그 결과를상위 32비트에 넣는다. 결과가 0이상(양수)이면 Remainder(나머지)를 shift left하고 LSB를 1로 둔다. 결과가 0미만(음수)면 다시 원래값으로 복원하고 shfit left한 뒤 LSB를 0으로 넣는다.  
    3. 위 과정을 반복하면 왼쪽 상위 32비트는 나머지가 저장되고, 오른쪽 하위 32비트는 몫이 위치하게 된다.  

부호가 있는 나눗셈들에선 나머지를 출력하는 기준이 있다.  
제수와 피제수 부호가 다르면 몫은 음수이고,
**피제수와 나머지의 부호가 항상 같도록 하는것이 원칙**이다.  
예를들어 제수:-2, 피제수:7인 상황이면, (7/(-2)) 몫:-3, 나머지:1로 한다. 수학공식이랑 다름(q=내림(a/b)이라 수학 공식대로하면 몫:-4, 나머지:-1이다)  

나눗셈은 곱셈처럼 병렬적 연산은 수행할 수 없지만, SRT devision이라는 알고리즘을 통해 각 단계마다 여러 몫비트를 예측하는 기법(현재는 4비트씩)을 사용하여 빠른 계산이 가능하다.  

**MIPS에서의 명령어**  
곱셈과 마찬가지로 결과값이 HI/LO 레지스터를 활용되어 저장된다.  
*div rs, rt / divu rs, rt* 를 사용하여 나눗셈을 사용할 수 있고, **HI에 32bits 나머지, LO에 32bits 몫**이 저장되기에 *mfhi, mflo* 를 통해 값을 사용할 수 있다.  

### 부동소수점
정수가 아닌 수를 표현할 때 부동소수점을 사용한다.  
또한 부동소수점을 사용하면 매우 작은수부터 매우 큰 수까지 나타낼 수 있다.  
C언어에서는 float 혹은 double이 부동소수점 방식에 속한다.  
> 컴퓨터 이진수에서 표현되는 형태는 아래와 같다.  
$+-1.xxxxxxx(2) * 2^{yyyy}$  

부동소수점은 비트 수에 따른 표현방식이 두가지 있다.  
- 단일 정밀도 (Single precision, 32-bits)  
- 2배 정밀도 (Double precision, 64-bits)  

정수가 아닌 수를 나타내가 위해 **고정소수점**이라는 직관적인 방법을 사용하기도 하였다. 하지만 구현이 편하다는 장점 빼고는 표현가능 범위도 적고, 정밀도도 낮은 문제때문에 거의 사용되지 않는다.  
> 10진수 7.625는 2진수로 111.101이고, 이를 고정소수점으로 나타내면 부호비트:0, 정수부:0000111, 소수부:10100000 이런방식

결국 고정소수점보다 부동소수점이 더욱 유용하게 사용되고 있다.  
> 부동소수점 방식으로 위에서 나타낸 7.625를 나타내면 111.101을 1.11101*2^{2}으로 먼저 바꿔주고, 지수부는 2기때문에 10, 가수부는 111101이 된다. (1 + .11101)  
결국 부호비트:0, 지수부:2+127(바이어스)=10000001, 가수부:11101000... 이다.  

단일정밀도와 2배정밀도가 표현하기 위한 비트수가 다른만큼 지수필드와 가수필드의 크기가 다르다.  
**단일정밀도** - 부호비트 1, 지수필드 8, 가수필드 23비트   
**2배정밀도** - 부호비트 1, 지수필드 11, 가수필드 52비트  
- 둘다 지수필드에 bias라는 값을 더해서 비트에 기입해넣는데, 그 이유는 음의 지수값을 표현하기 위해서이다.  
따라서 단일정밀도는 127을 bias로 더하여 2^{-126}에서2^{127}을 나타내고, 2배정밀도는 1023을 bias로 하며 2^{-1022}에서2^{1023}을 나타낼 수 있다.  

**부동소수점의 표현 형식**  
$x = (-1)^s * (1+Fraction;지수필드) * 2^{Exponent;지수필드-Bias}$  

부동소수점 표현에서 지수필드는 -126에서127(2배정밀도는 -  1022에서1023)을 나타낸다 했는데, 왜 8비트에서 -127에서128이 아닌, 좀 더 작은 범위일까?  
**그 이유는 00000000과 11111111은 다른 수를 표현하기 위한 특수비트들이기 때문이다.**  
00000000은 잠복비트가 없음을 나타내기에 수가 0.xxxx인 경우에 -127의 지수, 0.f의 유효숫자를 갖는다는걸 의미한다. 또한 가수필드도 000...이면 전체 수는 0을 나타낸다.  
11111111은 가수필드가 모두 0이거나 모두0이 아닌경우로 나뉘는데 가수필드가 모두 0이면 무한대 혹은 -무한대이고, 모두 0이 아니면 NaN값이다.  

따라서 단일정밀도에서 표현하는 가장 작은수와 가장 큰수를 나타낼 때 지수는 00000001와 11111110이다. (-126, 127)  
가수는 000...00으로 유효자리가 1.0인 경우와 111..11인 경우로 유효자리가 거의 2.0에 근접하는 경우이다.  
두 경우 나타내어지는 수는  
+-1.0 * 2^{-126} = +-1.2 * 10^{-38}과  
+-2.0 * 2^{+127} = +-3.4 * 10^{+38}이다.  

2배 정밀도에서도 비트만 달라지고 경우는 똑같다.  
+-1.0 * 2^{-1022} = +-2.2 * 10^{-308}  
+-2.0 * 2^{+1023} = +-1.8 * 10^{+308}이다.  

**Overflow와 UnderFlow (오버플로와 언더플로)**  
표현가능한 범위가 넓긴한데 그래도 범위가 존재하긴하니까 Overflow와 UnderFlow가 발생할 수 있다.  
- Overflow는 주어진 표현방식의 범위를 넘어선 수가 입력될때 발생하고 값이 변경되는 심각한 오류가 발생하게 된다. 예를들어 단일정밀도에서 1.0 * 2^{130}이 입력되면 발생한다.  
- Underflow는 주어진 표현방식의 범위가 수를 정확히 표시하기엔 부족해서 소수부분을 정확히 표현할 수 없을 때 발생한다. 근데 그리 큰 오류가 아니다. 1.0 * 2^{-130} 이런 경우에 발생  

> 예시로 -0.75를 부동소수점으로 표현하면, 먼저 이진수로 나타낸다.  
0.75 * 2 => '1'.5 * 2 => '1'.0 이니 0.11(2)이고 이는 1.1 * 2^{-1}이다.  
단일정밀도 - 부호비트 : 1, 지수필드 : -1+127 = 126 = 01111110(2), 가수필드 : 100000...(2)  
2배정밀도 - 부호비트 : 1, 지수필드 : -1+1023 = 1022 = 01111111110(2), 가수필드 : 1000...(2)  

> 반대의 경우도 구한다. 11000000101000...00가 단일정밀도 표현일때 어떠한 수인지 구해보면, 1(부호비트) 10000001(지수필드) 01000..000으(가수필드) 이렇게 세 부분으로 나눈다.  
지수필드가 129이기에 -127 = 2이나온다. 정리해서 작성하면 -1.01 * 2^{2} 이다. 이는 -101.0이고, 10진수로 나타내면 **-5.0** 이다.

### 부동소수점 덧셈  
부동소수점은 덧셈을 하기 위한 단계가 존재한다.  
1. 소수점을 큰 지수 기준으로 맞춘다.  
예를들어 10진수 4비트 상황에서 9.999 * 10^1 + 1.610 * 10^{-1}이 있다면 9.999 * 10^1 + 0.016 * 10^1로 맞추어준다.
2. 유효숫자를 더한다.  
9.999와 0.016을 더해 10.015 * 10^1으로 만들어준다.
3. 정규화와 오버플로/언더플로 검사를 한다.  
1.0015 * 10^2로 변환된다. 근데 4비트 표현범위를 벗어남  
4. 필요하다면 반올림 후 다시 정규화/검사를 한다.  
4비트에 맞게 1.002 * 10^2 로 반올림했다. 정규화가 다시 필요하지 않으니 이상태로 마무리  

> 이진수도 위 과정과 동일하다고 보면 된다.  
1.000 * 2^{-1} + -1.110 * 2^{-2} 상황  
1.000 * 2^{-1} + -0.111 * 2^{-1} 로 지수를 맞추어준다.  
0.001 * 2^{-1}로 유효숫자끼리 더한 값을 낸다.  
정규화하여 1.000 * 2^{-4}으로 만든 후 오버플로 언더플로 검사  
비트수가 맞기에 반올림 필요 없다.  
10진수로 바꾸면 0.0001에서 1.0 / 2 = 0.5 => 0.5 / 2 = 0.25 => 0.25 / 2 = 0.125 => 0.125 / 2 = 0.0625 이다.  
(0.0001에서 뒤에부터 가져와서 '1'.0 / 2 = 0.5 이고 그 다음엔 1앞에 있는 '0'.5 인데 이 .5는 위에 1.0/2에서 구한 소수점을 가져온다)
따라서 답은 0.0625  

### 부동소수점 하드웨어  
정수 덧셈보다 당연히 훨씬 복잡하다.  
그래서 한 클럭 사이클동안 이루어지기에는 너무 길다!  
따라서 부동소수점 덧셈기는 여러 클럭사이클로 이루어져있고, 파이프라인화가 될 수 있다.  
1. 지수 비교, 비교 후 더 작은 지수를 큰 지수에 맞추어 지수값을 shift left해줄것이기에, 작은 지수를 갖는 수의 지수에 맞춰 가수필드를 right로 shift해준다.  
2. Big ALU를 통해 가수필드 더하여 유효숫자를 더해준다.  
3. 더해진 유효숫자를 정규화하기 위해 1.xxx 형태가 되도록 가수필드를 shift left or shift right 해준다.  
4. 표현가능한 비트수에 맞게 반올림하고 반올림이 필요없다면 그대로 값을 내고, 반올림을 한 이후 정규화가 추가로 필요하다면 정규화 과정으로 다시 돌아간다.

부동소수점 곱셈기는 덧셈기와 비슷한 복잡도를 갖는다. 유효숫자의 곱셈을 진행하면 됨.  
부동소수점 산술연산 하드웨어는 덧셈, 뺄셈, 곱셈, 나눗셈, 역수, 루트 등을 수행하고 대개 여러클럭 사이클을 소요하기에 파이프라인화가 될 수 있다.  

- 부동소수점 연산은 보조프로세서를 활용한다.  
단일정밀도는 $f0, $f1... $f31의 프로세서를 활용하고  
2배정밀도는 $f0을 사용하기위해 $f0/$f1을 사용.. $30까지 총 16개 사용가능하다.  
- 부동소수점 명령어는 부동소수점 레지스터($f...)에서만 동작한다  
- lwc1, l.d, swc1, s.d와 같은 형태로 명령어사용  
단일정밀도는 .s이고 2배정밀도는 .d가 붙는다.  
add.s, sub.s, mul.s, div.s처럼 사용가능  
add.d, sub.d, mul.d, div.d는 2배정밀도 경우임  
2배정밀도는 2개씩 레지스터를 사용하기에 mul.d $f4, $f4, $f6처럼 짝수단위로 사용해야할것.  
비교명령어 eq, lt, le같은 기능은 c.xx.s, c.xx.d로 사용할 수 있다.  
분기명령어는 bc1t, bc1f(true, false)로 사용한다. cond비트가 참이거나 거짓일때 목적레이블로 분기함  







## Chapter 04
## Chapter 05