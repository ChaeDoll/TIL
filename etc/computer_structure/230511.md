# 컴퓨터구조 11주차 강의  
나눗셈 개선구조 쓴거 날라감..  
divisor와 ALU가 32비트로 개선됨.  
결과 나타내는 64비트에서 상위 32비트는 나머지, 하위 32비트는 몫을 나타냄  

### 부동소수점 표현  
부호비트, 정수부, 수소부 이렇게 고정소수점 표현방식이 있는데 덧셈뺄셈 빼고 표현이 쉽다.  
하지만 표현가능한 수의 범위와 정밀도가 너무 떨어져서 활용되지 않다.  

우리가 배우고자하는 방식은 부동소수점 방식으로 표현하려한다.  
비트를 많이 아낄수있기에 좋다.  
부동소수점 표현방식은 1.11101*2^{2} 이런 방식으로 적힌다.  
표현이나 연산에는 조금 복잡해보이긴하지만, 더 넓은 표현범위, 높은 정밀도를 갖는다.  

단일정밀도 : 32비트 - 부호 1비트, 지수 8비트, 가수 23비트  
2배정밀도 : 64비트 - 부호 1비트, 지수 11비트, 가수 52비트  
Exponent(지수 필드), Fraction(가수 필드)  

x = (-1)^s * (1+Fraction) * 2^(Exponent-Bias)  
Fraction에 잠복비트 1을 더한다. (지수필드가 00000000 인경우 제외)  
지수를 비교하기 용이하게 bias를 사용함...  
단일은 Bias가 127, 2배는 Bias가 1203  
단일은 지수부분이 2^128까지 나타낼수가 있다는것이고, 2배는 지수 2^1204까지 나타낼 수 있다는 것임  

지수필드가 00000000이랑 11111111은 다른수를 표현하기 위해 쓰임?  
00000000은 잠복비트가 없을을 나타냄. 수를 나타낼때 1에서다가 더함.  
지수필드가 00000000이면 따라서 유효숫자부분이 0.xxxx가 된다.  
지수는 00000000 / 가수는 유효숫자가 0.xxxx니까 0.f이다.  
가수필드가 00000이라면 전체수는 0을 나타낼 수 있다.  
만약 지수필드가 11111111 인 경우에서,  
가수필드가 모두 0이면 무한대 (혹은 -무한대), 가수필드가 모두 0이 아니면 NaN  

### 범위  
지수필드가 0000....0000 에서 1111.1111 사이 수일때  
가장 작은수는 지수필드 : 00000001  
실제 지수 = 1-127 = -126  
가수 필드 : 000...00 => 유효자리 = 1.0  
+-1.0 * 2^(-126) 은 ~= <b>+-1.2*10^(-38)</b> 이다.  
가장 큰 수는 지수필드 : 11111110이고 (실제 지수 = 254-127=+127)  
가수필드 : 111...11 => 유효자리 ~= 2.0  
+=2.0*2^(127) ~= <b>+-1.8 * 10^(38)</b> 이다.  

2배 정밀도에서는 가장작은수는 실제지수 -1022 => +-2.2*10^(-308)  
가장큰수는 +1023이고 유효자리 2.0이라 +-1.8*10^(308)이다.  

오버플로, 언더플로  
오버플로는 넘어가버리는 것. 수 표현에 문제가 생길수있기에 치명적. 예를들면 2^130 같은 경우.  
언더플로는 정밀도 차이만 있을뿐 큰 문제가 되지 않음.  

예시를 들어보자.  
-0.75를 표현한다면 -0.75 = (-1)^1 * 1.1(2) * 2^(-1)  
부호는 1이고, 가수필드는 1000..00(2)이고 지수필드는 지수필드-Bias한 값인데, 이게 2^-1이니까..  
-1+Bias=지수필드 이다. 따라서 단일이라면 126 (01111110), 2배면 1022 (01111111110)가 지수필드값이다.  
단일일때는... : 1011111101000...00  
2배일때 : 1011111111101000...00 이다.  
