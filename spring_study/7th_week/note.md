# 7주차 - 섹션 2 중간 ~ 섹션 3

### 회원 도메인 실행과 테스트  
기본 자바로 구현하는 모습.  순수한 자바이고 스프링없이 해보았다.  
그런데 이 방식은 한계가 있음. 좋은 방식이 아니기에 Junit이라는 프레임워크를 사용할 것임  
요즘 코딩을 하려면 테스트 코드는 선택이 아닌 필수이다.  
join이라는 메소드를 테스트 코드를 통해서 검증해보았음.  
회원 도메인 코드가 설계 상 문제가 있을 것임. 무엇인가???  
다른 저장소로 변경할 때 OCP를 잘 준수할지, DIP는 잘 준수하는지.  
결국에는 한계가 있다. 구체화에 의존하는 문제가 있다...  

### 주문과 할인 도메인 설계  
회원은 상품을 주문할 수 있는데, 회원 등급에 따라 할인 정책이 달라지는 것.  
VIP의 경우 모든 상품에 1000원을 고정 할인해 줌. 근데 나중에 변경 가능.  
할인 정책은 변경 가능성이 높고 회사는 확신이 없다. 오픈 전까지 미루는 상황..  
이러한 미확정 상황에서 어떻게 해야할까?  
클라이언트의 주문 생성을 요청 => 주문 서비스는 회원의 ID를 조회하여 회원의 등급을 확인한다 => 그리고 회원 등급에 따라 할인을 적용 => 주문 서비스에서 할인 결과를 포함하여 주문 결과를 반환  
위 상황을 고려하여 할인 정책의 경우 여러 가능성을 구현체 여러개로 만들어 두고 구현체만 바꿔 끼우면 된다.  
( 보통 구현체가 단 하나만 있으면 interface명 뒤에 Impl이라고 적는 편이다.  
ex - OrderService 인터페이스의 구현체 OrderServiceImpl )  
이렇게 가능성을 만들어두고 갈아끼우면 주문서비스 쪽은 변경하지 않고 완성할 수 있다.  

### 주문과 할인 도메인 개발  
할인 패키지를 만들고 그 안에 할인정책 인터페이스를 만든 뒤, 고정금액할인 방식으로 구현한다. 차후 비율할인도 만들어 놓을 수 있음.  
주문패키지를 만들어 그 안에서 할인 비율에 따른 계산을 하여 결과값을 도출할 수 있도록 만든다.  
나중에 보기 편리하도록 toString()기능을 사용했다. 이러면 print로 order 객체만 출력하면 자동으로 toString 메소드가 실행된다.  
OrderService를 구현해야하는데 이곳에서 주문을 요청받을 때 클라이언트의 회원정보와 상품, 그리고 가격을 넘기게 된다.  
OrderServiceImpl에서 먼저 회원데이터베이스, 할인정책을 구현하고 (현재는 우선 메모리DB, 고정할인정책) OrderService의 주문생성 메소드를 오버라이딩한다.  
데이터베이스와 할인정책을 통해서 얻은 회원의ID, 아이템의 이름과 가격을 받은 뒤 이것들을 사용하여 Order객체에 이 값들을 포함시켜준다.  

### 주문과 할인 도메인 실행과 테스트  
메인, 테스트 둘다 테스트 해본 결과 문제 없이 잘 구현되었다.  
![image1](https://user-images.githubusercontent.com/108540812/217837600-9dbbcc53-f6b8-4549-a381-35e449c22a7f.png)  

## 섹션3  

### 새로운 할인 정책
새로운 정책을 적용하려하니 문제... DIP, OCP를 못지킴  
이걸 해결하고자 여러 과정을 거치는데 이를 거치다보면 스프링컨테이너가 왜 탄생했나 알 수 있게 된다.  
새로운 할인정책은 고정할인이 아닌, 정률할인으로 적용시키는 것!  
1000원을 할인해주는 기존 정책과 달리 이번에는 10%를 할인해주는 정책이다.  
> 애자일 소프트웨어 선언 - 공정과 도구보다 개인과 상호작용을,  
포괄적 문서보단 작동하는 소프트웨어를,  
계약 협상보다 고객과의 협력을,  
계획을 따르기보다 변화에 대응하기를

을 의미한다.  
Ctrl+Shift+T로 테스트를 생성할 수 있다.  
VIP일 경우, BASIC일 경우 두가지의 경우에서 할인이 잘 적용되고 적용되지 않는지 확인하였다.  

### 새로운 할인 정책의 문제점  
적용을 위해선 OrderServiceImpl로 가서 discountPolicy 대상을 변경해야함(고정-> 정률)  
즉, 할인정책을 변경하려면 클라이언트인 OrderServiceImpl를 고쳐야하는 것이다.  
이게 무엇이 문제? -> 역할구현 충실히 분리하였고 다형성 활용하고 인터페이스와 구현객체 구현했다. 하지만...  
OCP와 DIP를 충실히 구현하지 못 했다.  
추상클래스인 DiscountPolicy만 아니라 구현클래스 Rate(Fix)DiscountPolicy에도 의존하고 있다.  
즉, 변경 및 확장을 위하여 클라이언트를 건드리는 상황이 나온 것! 이것은 DIP의 위반이다.  
항상 추상화에만 의존하라는 DIP에 위반을 한 것인데.. 이 때문에 할인정책을 변경하기 위해 클라이언트(OrderServiceImpl)의 코드도 변경해야 하는 OCP위반까지 함께 동반되는 것이다.  
근데 이 두개를 위반하지 않고 구현하는 것이 가능할까?  
DIP를 위반하지 않도록 인터페이스에만 의존하도록 의존관계를 변경해야 함  
구현체에 의존하는 것을 다 지우는 것이다.  
구현체가 없는데 어떻게 실행이 되는가... 실제로 실행하면 에러가 난다.  
해결 -> 누군가 구현객체를 대신 생성하고 주입해주어야 한다. 그러면 해결이 된다.  

### 관심사의 분리  
공연을 떠올려보면 각각의 인터페이스가 배우의 역할이다. 그러면 실제 배역에 맞는 배우는 누가 선택??  
배우의 역할이 배역을 고르는게 아니라, 실제론 공연기획자가 배역에 맞는 배우들을 섭외할 것이다.  
이처럼 관심사를 분리하여 구현객체를 생성하고 이를 연결하여 의존관계를 주입해주는 일을 수행하는 설정클래스를 만들어야 한다.  
애플리케이션도 이런 방식으로 개발되어야 한다. 본인의 역할만 수행하도록 해야함.  
> AppConfig의 등장

MemberServiceImpl의 구현체 대신 생성자를 사용하여 입력된 설정에 맞는 구현체를 구현한다. 생성자를 통한 생성자 주입  
OrderServiceImpl도 생성자로 다 받아낸다.  
이 형태를 통해 멤버서비스구현체, 오더서비스구현체들은 본인들에게 어떠한 구현체가 들어올지 모르는 코드가 완성된다. AppConfig에서 생성자를 통해 생성하여 넘겨주기 때문에 그때야 알게 된다.  
어떤 구현객체가 들어올 지는 AppConfig를 통해서만 결정된다.  
이제 Impl들은 의존관계 고민 없이 실행에만 집중하면 되는 것이다.  
관심사가 잘 분리되었다!  
이 모습이 클라이언트 입장에서는 외부에서 의존관계를 넣어주는 것과 같다고하여 이것을 DI(Dependency Injection), 의존관계 주입 이라고 부른다.  
MemberApp과 OrderApp에 둘 다 AppConfig를 만들어서 이를 사용하여 구체화하도록 설정하면, 이제 이 둘도 구현체에 의존하지 않는 상태로 만들 수 있다.  
Test의 경우에는 여러 구문이 실행될 수 있으니 @BeforeEach구문을 사용하여 테스트 메소드가 실행될 때마다 AppConfig가 생성되고 각 memberService나 orderService에 appconfig의 메소드들로 인하여 생성자주입이 실행되도록 설정해두었다.  
이제 DIP는 잘 지켜지게 되었다.  
이처럼 AppConfig로 관심사를 확 분리하였다. 이제부터는 AppConfig가 구현체를 설정할 것이다.  
각 클래스들은 본인들의 기능을 실행하는 데에만 집중하면 된다.  
