# 스프링 스터디 10주차 내용정리 

## 섹션7 이어서..  
### 조회된 빈이 2개일 때  
@Autowired는 빈의 타입으로 조회를 하기 때문에 만약 같은 타입의 빈이 2개 이상이라면 연결에 문제가 생긴다.  
예를 들어 DiscountPolicy를 FixDiscount, RateDiscount 둘 다 구현을 해버리면 둘 다 등록이 될 것이다.  
빈이 2개가 발견되었다고 오류가 발생하고 종료된다.  
이에 대한 해결방법은 무엇일까? 스프링 빈을 수동등록하는 방법도 있다.  
하지만 DI(의존관계 주입)단계에서 이 문제를 해결할 수도 있다.  

### @Autowired 필드명 사용, @Qualifier, @Primary  
위에서 언급한 오류를 해결하는 방법은 크게 3가지이다.  
- @Autowired 필드 명을 사용하여 매칭  
- @Qualifier 끼리 매칭  
- @Primary 사용  
우선 @Autowired의 필드명이란 무엇이냐면, 아예 Autowired를 사용하는 메소드 매개변수를 원하는 대상 타입->필드명 을 사용하는 것이다.  
기존에 타입을 DiscountPolicy discountPolicy의 형태처럼 작성했다면,  
DiscountPolicy rateDiscountPolicy 처럼 아예 원하는 필드명을 지정하면 이를 해결할 수 있다.  
@Autowired는 같은 타입을 매칭시켜주는 역할을 갖고있고, 혹여나 매칭 결과가 2개 이상이면 파라미터명(필드명)을 보고 매칭을 시켜준다.  
두 번째 방법인 @Qualifier은 '추가 구분자'를 더해주는 기능이다.  
주입할 때 추가적인 방법을 제공하는 것으로 빈 이름을 변경하는 방법이 아니다.  
@Component를 작성한 빈을 대상으로 @Component 아래에 @Qualifier("fixDiscountPolicy")의 방식으로 구분자를 넣는다.  
그리고 @Autowired를 사용하는 메소드의 매개변수인 DiscountPolicy discountPolicy에서 @Qualifier("fixDiscountPolicy") DiscountPolicy discountPolicy 의 방식으로 매개변수를 작성해주면 된다.  
만약 fixDiscountPolicy라는 것을 찾지 못하면 추가로 fixDiscountPolicy라는 이름의 스프링 빈을 탐색한다. 이 기능은 그닥 사용하지 않는다.  
마지막으로 @Primary는 스프링 빈에 우선순위를 부여하는 방식이다.  
@Component 아래에 추가로 @Primary라는 애노테이션을 붙이기만 하면 된다.  
RateDiscountPolicy 와 FixDiscountPolicy를 둘 다 구현했다고 가정하면, 기존에는 같은 DiscountPolicy 타입으로 두개가 조회되어 오류가 나타날 것이다.  
하지만 @Primary를 RateDiscountPolicy 에 추가해준다면 우선적으로 이곳에 의존관계가 주입될 것이다.  
@Qualifier와 @Primary의 장단점이 있다면, @Qualifier는 주입 받기 위해 모든 코드에 @Qualifier를 추가해야하는 단점이 있다.  
반면 @Primary는 단순하게 한줄만 추가하면 된다.  
하지만 우선순위로 보면, Primary보다 Quailfier가 더 우선순위가 높다. 더 상세한 코드기 때문이다.  

### 애노테이션 직접 만들기  
애노테이션을 직접 만들수도 있다. 이건 실무에서도 사용하곤 한다.  
public class... 대신 public @interface 로 작성하면 정의가 가능하다.  
애노테이션은 상속이라는 개념이 없다. 애노테이션을 모아서 사용하는건 스프링이 지원하는 기능이다.  
@Quilfier뿐만 아니라 다른 애노테이션들도 함께 조합하여 상용가능하다.  
이처럼 재정의도 가능하지만, 스프링이 제공하는 기능을 무분별히 재정의하면 혼란스러울 수 있다.  

### 의도적으로 조회한 빈들이 모두 필요할 때  
예를 들어 클라이언트가 할인의 종류를 Fix와 Rate 중 선택할 수 있도록 한다면 이와 같은 상황일 것이다.  
스프링을 사용하면 이런 전략패턴을 간단하여 구현할 수 있다.  
Map을 사용하여 모든 빈을 주입받고 이때 메소드의 코드값을 받아 fixDiscountPolicy를 받으면 map에서 fixDiscountPolicy 빈을 찾아서 실행시킨다.  
마찬가지로 코드값을 받아 rateDiscountPolicy가 넘어오면 이를 찾아서 실행시킴  

### 자동과 수동의 올바른 실무 운영 기준  
실무에서는 "편리한 자동 기능을 기본으로 사용하자" 라는 것이 일반적으로 되어있다.  
어떤 경우에 컴포넌트 스캔을 할지(자동주입), 어떤 경우에 설정 정보를 통해 수동으로 빈을 등록한 뒤 의존관계도 수동으로 넣어야 하는지 알아야 한다.  
스프링이 등장하고나서부터는 자동을 추구하는 편으로 향하고 있다.  
개발자 입장에서 생각해보면 스프링 빈 하나를 등록하기 위해 일일이 @Bean을 적고 객체 생성하고 의존관계를 하나하나 주입해주는 일 보다는 @Component를 붙이는 것이 훨씬 편할 것이다.  
결정적으로 자동을 쓰는 이유 -> 자동을 사용해도 OCP, DIP를 지킬 수 있다.  
그렇다면 수동 빈 등록은 어떤 때에 사용하는가?  
애플리케이션은 업무 로직, 기술지원 로직 크게 두개로 나뉜다.  
컨트롤러, 서비스, 리포지토리 등 추가되거나 변경되거나 하는 업무 로직들을 말한다. 일반적인 대부분의 작업들  
기술지원 빈은 기술적인 문제나 공통적인 관심사를 처리할 때 사용되는 빈을 의미한다.  
업무로직은 유사한 패턴이 있고 양이 매우 많다. 그렇기에 자동으로 처리하는게 편리하다.  
하지만 기술지원 로직은 양은 매우 적으나 그 영향력이 애플리케이션 전반적으로 광범위하게 큰 영향을 끼치기 쉽다.  
그렇기에 이런 경우 수동으로 등록하여 명확하게 드러나도록 하는 경우가 많다.  
업무로직에서도 물론 수동으로 사용하는 것이 좋을 때도 있다.  
우리가 위에서 Map을 사용하여 rate, fix의 DiscountPolicy를 사용했는데, 이렇게 나뉘는 경우에 차라리 수동으로 등록하여 사용자가 코드만 보고도 파악하기 쉽게 만들수도 있는 것이다.  
본인만 알고 넘어간다고 끝이 아님! 개발하다보면 다른 사람들도 내 코드를 봐야하는 경우가 있다는 걸 명시..  
위 경우에 자동으로 등록한다면 최소한 특정패키지에 같이 묶어있기라도 하면 좋다.  
자동으로 하던 수동으로 하던 결국 중요한 것은 '한 눈에 보고 이해가 되는가' 이다.  
