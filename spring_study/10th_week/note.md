# 스프링 스터디 10주차 내용정리 

## 섹션7 이어서..  
### 조회된 빈이 2개일 때  
@Autowired는 빈의 타입으로 조회를 하기 때문에 만약 같은 타입의 빈이 2개 이상이라면 연결에 문제가 생긴다.  
예를 들어 DiscountPolicy를 FixDiscount, RateDiscount 둘 다 구현을 해버리면 둘 다 등록이 될 것이다.  
빈이 2개가 발견되었다고 오류가 발생하고 종료된다.  
이에 대한 해결방법은 무엇일까? 스프링 빈을 수동등록하는 방법도 있다.  
하지만 DI(의존관계 주입)단계에서 이 문제를 해결할 수도 있다.  

### @Autowired 필드명 사용, @Qualifier, @Primary  
위에서 언급한 오류를 해결하는 방법은 크게 3가지이다.  
- @Autowired 필드 명을 사용하여 매칭  
- @Qualifier 끼리 매칭  
- @Primary 사용  

우선 @Autowired의 필드명이란 무엇이냐면, 아예 Autowired를 사용하는 메소드 매개변수를 원하는 대상 타입->필드명 을 사용하는 것이다.  
기존에 타입을 DiscountPolicy discountPolicy의 형태처럼 작성했다면,  
DiscountPolicy rateDiscountPolicy 처럼 아예 원하는 필드명을 지정하면 이를 해결할 수 있다.  
@Autowired는 같은 타입을 매칭시켜주는 역할을 갖고있고, 혹여나 매칭 결과가 2개 이상이면 파라미터명(필드명)을 보고 매칭을 시켜준다.  
두 번째 방법인 @Qualifier은 '추가 구분자'를 더해주는 기능이다.  
주입할 때 추가적인 방법을 제공하는 것으로 빈 이름을 변경하는 방법이 아니다.  
@Component를 작성한 빈을 대상으로 @Component 아래에 @Qualifier("fixDiscountPolicy")의 방식으로 구분자를 넣는다.  
그리고 @Autowired를 사용하는 메소드의 매개변수인 DiscountPolicy discountPolicy에서 @Qualifier("fixDiscountPolicy") DiscountPolicy discountPolicy 의 방식으로 매개변수를 작성해주면 된다.  
만약 fixDiscountPolicy라는 것을 찾지 못하면 추가로 fixDiscountPolicy라는 이름의 스프링 빈을 탐색한다. 이 기능은 그닥 사용하지 않는다.  
마지막으로 @Primary는 스프링 빈에 우선순위를 부여하는 방식이다.  
@Component 아래에 추가로 @Primary라는 애노테이션을 붙이기만 하면 된다.  
RateDiscountPolicy 와 FixDiscountPolicy를 둘 다 구현했다고 가정하면, 기존에는 같은 DiscountPolicy 타입으로 두개가 조회되어 오류가 나타날 것이다.  
하지만 @Primary를 RateDiscountPolicy 에 추가해준다면 우선적으로 이곳에 의존관계가 주입될 것이다.  
@Qualifier와 @Primary의 장단점이 있다면, @Qualifier는 주입 받기 위해 모든 코드에 @Qualifier를 추가해야하는 단점이 있다.  
반면 @Primary는 단순하게 한줄만 추가하면 된다.  
하지만 우선순위로 보면, Primary보다 Quailfier가 더 우선순위가 높다. 더 상세한 코드기 때문이다.  

### 애노테이션 직접 만들기  
애노테이션을 직접 만들수도 있다. 이건 실무에서도 사용하곤 한다.  
public class... 대신 public @interface 로 작성하면 정의가 가능하다.  
애노테이션은 상속이라는 개념이 없다. 애노테이션을 모아서 사용하는건 스프링이 지원하는 기능이다.  
@Quilfier뿐만 아니라 다른 애노테이션들도 함께 조합하여 상용가능하다.  
이처럼 재정의도 가능하지만, 스프링이 제공하는 기능을 무분별히 재정의하면 혼란스러울 수 있다.  

### 의도적으로 조회한 빈들이 모두 필요할 때  
예를 들어 클라이언트가 할인의 종류를 Fix와 Rate 중 선택할 수 있도록 한다면 이와 같은 상황일 것이다.  
스프링을 사용하면 이런 전략패턴을 간단하여 구현할 수 있다.  
Map을 사용하여 모든 빈을 주입받고 이때 메소드의 코드값을 받아 fixDiscountPolicy를 받으면 map에서 fixDiscountPolicy 빈을 찾아서 실행시킨다.  
마찬가지로 코드값을 받아 rateDiscountPolicy가 넘어오면 이를 찾아서 실행시킴  

### 자동과 수동의 올바른 실무 운영 기준  
실무에서는 "편리한 자동 기능을 기본으로 사용하자" 라는 것이 일반적으로 되어있다.  
어떤 경우에 컴포넌트 스캔을 할지(자동주입), 어떤 경우에 설정 정보를 통해 수동으로 빈을 등록한 뒤 의존관계도 수동으로 넣어야 하는지 알아야 한다.  
스프링이 등장하고나서부터는 자동을 추구하는 편으로 향하고 있다.  
개발자 입장에서 생각해보면 스프링 빈 하나를 등록하기 위해 일일이 @Bean을 적고 객체 생성하고 의존관계를 하나하나 주입해주는 일 보다는 @Component를 붙이는 것이 훨씬 편할 것이다.  
결정적으로 자동을 쓰는 이유 -> 자동을 사용해도 OCP, DIP를 지킬 수 있다.  
그렇다면 수동 빈 등록은 어떤 때에 사용하는가?  
애플리케이션은 업무 로직, 기술지원 로직 크게 두개로 나뉜다.  
컨트롤러, 서비스, 리포지토리 등 추가되거나 변경되거나 하는 업무 로직들을 말한다. 일반적인 대부분의 작업들  
기술지원 빈은 기술적인 문제나 공통적인 관심사를 처리할 때 사용되는 빈을 의미한다.  
업무로직은 유사한 패턴이 있고 양이 매우 많다. 그렇기에 자동으로 처리하는게 편리하다.  
하지만 기술지원 로직은 양은 매우 적으나 그 영향력이 애플리케이션 전반적으로 광범위하게 큰 영향을 끼치기 쉽다.  
그렇기에 이런 경우 수동으로 등록하여 명확하게 드러나도록 하는 경우가 많다.  
업무로직에서도 물론 수동으로 사용하는 것이 좋을 때도 있다.  
우리가 위에서 Map을 사용하여 rate, fix의 DiscountPolicy를 사용했는데, 이렇게 나뉘는 경우에 차라리 수동으로 등록하여 사용자가 코드만 보고도 파악하기 쉽게 만들수도 있는 것이다.  
본인만 알고 넘어간다고 끝이 아님! 개발하다보면 다른 사람들도 내 코드를 봐야하는 경우가 있다는 걸 명시..  
위 경우에 자동으로 등록한다면 최소한 특정패키지에 같이 묶어있기라도 하면 좋다.  
자동으로 하던 수동으로 하던 결국 중요한 것은 '한 눈에 보고 이해가 되는가' 이다.  
> 정리하면, 편리한 자동 기능을 기본으로 사용
직접 등록하는 기술지원 객체는 수동 등록  
다형성을 적극 활용하는 업무 객체도 수동 등록을 고민  

## 섹션8  
### 빈 생명주기 콜백 시작  
스프링이 생성되기 전, 종료되기 직전.. 이렇게 두 경우에 동작하는 메소드를 정의할 수도 있다. 일단 빈 생명주기를 먼저 알아본다.  
애플리케이션이 켜지기 전에 애플리케이션 서버와 데이터베이스와 미리 연결을 해둔다.  예열하는 것과 비슷하다고 생각하면 된다.  
또 애플리케이션이 종료될 때 안전하게 종료처리 할 수 있도록 해야하는데 이것도 스프링 지원한다.  
기본 ApplicationContext는 close가 없는데 하위인 ConfigurableApp...에는 close()라는 메소드가 있다.  
생성만 하고 로직을 호출하지 않으면 당연히 null이 나옴  
스프링빈은 객체생성->의존관계주입 단계로 라이프사이클을 가진다.  
이 순서를 마치고 나서야 필요한 데이터를 사용할 수 있는 준비를 마친다.  
따라서 초기화 작업은 의존관계 주입까지 모두 완료하고 호출해야 한다. 이러한 시점은 어떻게 아는가?  
'콜백 메소드'를 사용하여 초기화 시점을 알려주는 기능을 스프링에서 제공한다.  
이 뿐만아니라 스프링 컨테이너가 종료되기 직전에 소멸 콜백을 주기도 하는데, 이를 활용하여 안전하게 종료 작업을 진행 가능하다.  
> 스프링 컨테이너 생성 -> 스프링 빈 생성 -> 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료  

객체를 생성할 때 생성자를 통해 한 번에 동작들을 수행할 수도 있다는 것은 알고 있을 것이다.  
하지만 단순 객체 생성이 아닌, 생성된 값을 활용하여 외부와 연결하는 무거운 동작을 해야하는 상황이라면 생성자를 통해 한 번에 처리하는 것은 좋은 선택이 아닐 수 있다.  
오히려 이런 경우에는 객체를 생성하는 부분과 초기화하는 부분을 명확히 나누어야한다.  
싱글톤 빈은 스프링컨테이너가 종료될 때 함께 종료된다.  
그렇기에 스프링컨테이너가 종료되기 직전에 싱글톤 빈들의 콜백이 발생한다.  
생명주기가 짧은 빈의 경우에는 컨테이너와 관련없이 빈이 소멸하기전에 콜백이 일어난다.  
스프링은 크게 3가지 방법으로 빈 생명주기 콜백을 지원한다.  
- 인터페이스(initializingBean, DisposableBean)  
- 설정 정보에 초기화 메소드, 종료 메소드 지정  
- @PostConstruct, @PreDestroy 애노테이션 지원  

인터페이스인InitializingBean과 DisposableBean을 설명하면, initializingBean 의 afterPropertiesSet()으로 메소드 초기화를 지원하고 DisposableBean 의 destroy() 메소드로 소멸을 지원한다.  
하지만 이런 메소드들은 스프링 전용 인터페이스이고 스프링에 의존적이다.  
인터페이스 방법은 스프링 초창기때나 한 것이고, 지금은 더 나은 방법이 있다.  
빈에다 @Bean(initMethod = "init", destoryMethod = "close")와 같이 설정 정보를저장할 수 있다.  
설정정보를 사용하면 그 메소드 이용을 자유롭게 사용가능하고 스프링 빈이 아닌 코드에 의존하지 않음.  
빈의 종료메소드에 속성을 파해쳐보면,, 아마 close나 shutdow이라는 이름의 메소드가 자동으로 호출되도록 자동으로 설정되어있을 것이다.  
@PostCunstruct, @PreDestroy 이 두 애노테이션을 통해 가장 편리하게 초기화, 종료 가능하다.  
최신 스프링에서 가장 권장하는 것이고, 스프링이 아닌 자바 표준으로 존재하는 기능이다.  
컴포넌트 스캔과 잘 어울리고 외부 라이브러리에 적용하지 못하는 단점 외엔 다 좋다.  
혹시 외부 라이브러리를 초기화, 종료해야하면 @Bean으로 등록을 하면 된다.  
정리하면, 이왕이면 @PostConstruct, @PreDestroy 사용하고 코드를 고칠 수 없는 외부 라이브러리라면 @Bean의 initMethod와 destroyMethod를 사용하자