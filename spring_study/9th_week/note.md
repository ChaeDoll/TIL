# 9주차 내용정리  

## 섹션6  
### 컴포넌트 스캔  
지금까지는 @Bean이나 XML의 <bean>을 통해 등록했음.  
우리가 한 것은 얼마 안되는 개수였지만 빈이 많아질수록 등록도 귀찮고 설정도 커지고 누락되기도 함. 반복 작업은 싫다.  
새롭게 AutoAppConfig를 만들 예정이다.  
@ComponentScan이라는 것을 @Configuration 아래에 작성하면 자동으로 등록하는 기능이 탑재된다.  
여기서 필터기능을 넣어서 뺄 것을 지정한다.  
이렇게 하면 @Bean으로 등록한 것이 하나도 없는 상태이다.  
Configuration도 Component로 등록되어 있어서 필터 기능으로 예외처리 한 것이다. 예외처리 안해도 되는데 이전의 코드를 유지하기 위해서...   
컴포넌트 스캔이란 무엇이냐, 말 그대로 @Component가 붙은 클래스를 스캔하여 스프링빈으로 등록하는 것  
이제 각 클래스에 컴포넌트스캔 대상이 되도록 @Component 애노테이션을 붙여준다.  
그런데 의존관계가 생성 안되지 않느냐? @Autowired를 사용하여 의존관계를 자동으로 연결해준다.  
스캔, 의존관계 주입이 어떻게 동작하냐면..  
컴포넌트스캔이 우선 @Component가 붙은 모든 클래스를 스프링빈으로 먼저 등록한다.  
이 때, 빈 이름은 객체클래스명을 사용하여 등록한다. 맨 앞글자만 소문자로 바꿔서!  
즉 MemberServiceImpl의 클래스는 빈으로 등록되면 memberServiceImpl로 등록됨  
빈 이름을 직접지정도 가능한데, @Component("memberService2") 이런식으로 직접 등록 가능  
@Autowired를 사용해 의존관계를 지정하는 방법은, 먼저 @Autowired를 생성자에 지정되면, 그 생성자의 매개변수(타입)를 갖는 스프링빈을 찾아서 주입시킨다.  
그럼 같은 타입이 여러개면? -> 충돌이 날 것이다. 이후 자세하게 설명  
getBean(MemberRepository.class)를 사용하는 것과 동일하다고 이해하면 된다.  
매개변수가 여러개인 것은 문제가 없다. 다 찾아준다. 하지만 같은 타입이 여러개 발생하면 그게 문제인 것이다. 제대로 구분하길!  
사실, 모든 자바 클래스를 탐색하면 시간이 꽤나 걸릴 것이다. 따라서 컴포넌트 범위를 설정할 수도 있다.  
@ComponentScan 뒤에 괄호를 사용하여 basePackages = "hello.core"과 같은 형태의 코드를 작성하면 시작 탐색 위치가 hello.core부터 시작된다.  
시작 위치를 여러개 지정할 수도 있다. 지정하지 않으면 @ComponentScan이 적힌 클래스가 존재하는 패키지가 시작위치가된다.  
시작위치를 설정하는 것도 좋지만, 사실 설정 정보 클래스를 최상단에 두는 것을 더 많이 쓰는 듯 하다.  
스캔 대상은 @Component 뿐만 아니라 @Controller @Service @Repository @Configuration 이 모든 것들이 스캔 대상이다. @interface 에 Controller, Service ...등이 인터페이스로 존재하고 그것들이 Component 등록이 되어있는 소스코드가 내포되어 있다.  
컴포넌트 스캔 필터로 excludeFilters를 썼었는데 includeFilters라는 것도 존재한다.  
필터타입은 5가지가 있는데 ANNOTATION(기본값, 어노테이션), ASSIGNABLE_TYPE(지정한 타입과 그 자식타입), ASPECTJ(AspectJ 패턴), REGEX(정규 표현식), CUSTOM(TypeFilter라는 인터페이스 구현하여 처리)가 있다.  
includeFilters는 잘 사용안하고 excludeFilters는 가끔 쓸일이 있지만 자주쓰진 않는다.  

컴포넌트 스캔으로 이름이 같은 빈을 받으면 오류가 난다. 수동빈과 자동빈을 선언하면 수동빈이 우선권을 가지고 자동빈을 오버라이딩 해버린다.  


## 섹션7  
### 의존관계 자동 주입  
의존관계 주입은 생성자 주입, 수정자 주입(setter), 필드 주입, 일반 메소드 주입 크게 4가지가 있다.  
